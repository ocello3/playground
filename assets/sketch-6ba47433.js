import{s as y,D as b,d as g,t as w,c as x}from"./tools-799dad41.js";import{d as k}from"./debug-7626b444.js";import{p as l}from"./index-1b8ea48e.js";const h=(t,a,r,n)=>{const e=n===void 0,o=(()=>{const s=a*t.circle.baseRadiusRate;if(e)return"max";if(n.status==="max")return"rotate";if(n.status==="rotate")return n.radius<0?"min":n.status;if(n.status==="min")return"back";if(n.status==="back")return n.radius>s?"max":n.status;throw`preStatus: ${n.status}`})(),c=(()=>{const s=a*t.circle.baseRadiusRate;if(e||o==="max")return s;if(o==="rotate")return n.radius-a*t.circle.radiusReducRate;if(o==="min")return 0;if(o==="back")return n.radius+a*t.circle.radiusIncreRate;throw`status: ${o}`})(),i=e?(()=>{const s=a*t.circle.centerXRate,u=a*.5;return new l.Vector(s,u)})():n.center,d=(()=>o==="rotate"?Math.PI*t.circle.bpm/1800:0)(),R=(()=>!e&&o==="rotate"&&n.angle<Math.PI*2?n.angle+n.rotationSpeed:0)(),f=(()=>{const s=new l.Vector(Math.cos(R),Math.sin(R)),u=l.Vector.mult(s,c);return l.Vector.add(i,u)})(),p=(()=>{if(e||o==="max")return[f];if(o==="back")return n.distals;const s=t.circle.baseRadiusRate/t.circle.radiusReducRate,u=Math.floor(s/t.circle.trackArrayResolution);return r%u===0?n.distals.concat(f):n.distals})();return{status:o,radius:c,center:i,rotationSpeed:d,angle:R,distal:f,distals:p}},m=(t,a,r,n)=>{const o=n===void 0?r*a.cum.distRate:n.dist,c=(()=>{const i=t.center.y,d=t.distal.x-Math.pow(Math.pow(o,2)-Math.pow(t.distal.y-i,2),.5);return new l.Vector(d,i)})();return{dist:o,pos:c}},I=()=>({circle:{baseRadiusRate:.25,radiusReducRate:4e-4,radiusIncreRate:.005,centerXRate:.7,bpm:40,sizeRate:.02,trackArrayResolution:80},cum:{distRate:.35},maxVolume:-10}),M=(t,a)=>{a.pages[1].addFolder({title:"circle"}).addInput(t.circle,"baseRadiusRate",{step:.1,min:.1,max:1}),a.pages[2].addInput(t,"maxVolume",{step:1,min:-60,max:0})},S=async()=>{const t=await y();return console.log(b.get()),{se:t}},V=(t,a,r,n,e)=>{e.push(),e.fill(0),e.circle(t.distal.x,t.distal.y,n*r.circle.sizeRate),e.circle(t.center.x,t.center.y,n*r.circle.sizeRate),e.pop(),e.push(),e.noFill(),e.circle(t.center.x,t.center.y,n*r.circle.baseRadiusRate*2),e.push(),e.noFill(),e.beginShape(),t.distals.forEach(o=>{e.curveVertex(o.x,o.y)}),e.endShape(),e.pop(),e.line(t.center.x,t.center.y,t.distal.x,t.distal.y),e.pop(),e.push(),e.fill(0),e.circle(a.pos.x,a.pos.y,n*r.circle.sizeRate),e.pop(),e.push(),e.line(t.distal.x,t.distal.y,a.pos.x,a.pos.y),e.pop(),e.push(),e.line(0,n*.5,n,n*.5),e.pop(),g(e,n)},$=t=>{const a=w.setSize("sketch");let r=x.setController();const n=I();let e,o,c;t.setup=async()=>{c=await S(),e=h(n,a,0),o=m(e,n,a),t.createCanvas(a,a);const i=x.setGui(t,r,c.se,!1);M(n,i),t.noLoop()},t.draw=()=>{if(c===void 0){t.noLoop();return}t.frameCount%5===0&&k({lib:0},10),t.background(255),x.updateController(t,r),e=h(n,a,t.frameCount,e),o=m(e,n,a,o),V(e,o,n,a,t)}};export{$ as sketch};
