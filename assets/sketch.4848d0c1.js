import{T as S,o as f,G,p as O,u as $,w as j,v as N,s as k,h as Y,t as _,l as q,c as A,d as V}from"./tools.74a75bcc.js";import{d as H}from"./debug.8b764ad3.js";import{G as W}from"./GrainPlayer.a3a2710d.js";import{p as b}from"./index.397c7aad.js";class T extends S{constructor(){super(f(T.getDefaults(),arguments,["channels"])),this.name="Split";const s=f(T.getDefaults(),arguments,["channels"]);this._splitter=this.input=this.output=this.context.createChannelSplitter(s.channels),this._internalChannels=[this._splitter]}static getDefaults(){return Object.assign(S.getDefaults(),{channels:2})}dispose(){return super.dispose(),this._splitter.disconnect(),this}}class P extends S{constructor(){super(f(P.getDefaults(),arguments,["type","size"])),this.name="Analyser",this._analysers=[],this._buffers=[];const s=f(P.getDefaults(),arguments,["type","size"]);this.input=this.output=this._gain=new G({context:this.context}),this._split=new T({context:this.context,channels:s.channels}),this.input.connect(this._split),O(s.channels,1);for(let t=0;t<s.channels;t++)this._analysers[t]=this.context.createAnalyser(),this._split.connect(this._analysers[t],t,0);this.size=s.size,this.type=s.type}static getDefaults(){return Object.assign(S.getDefaults(),{size:1024,smoothing:.8,type:"fft",channels:1})}getValue(){return this._analysers.forEach((s,t)=>{const n=this._buffers[t];this._type==="fft"?s.getFloatFrequencyData(n):this._type==="waveform"&&s.getFloatTimeDomainData(n)}),this.channels===1?this._buffers[0]:this._buffers}get size(){return this._analysers[0].frequencyBinCount}set size(s){this._analysers.forEach((t,n)=>{t.fftSize=s*2,this._buffers[n]=new Float32Array(s)})}get channels(){return this._analysers.length}get type(){return this._type}set type(s){$(s==="waveform"||s==="fft",`Analyser: invalid type: ${s}`),this._type=s}get smoothing(){return this._analysers[0].smoothingTimeConstant}set smoothing(s){this._analysers.forEach(t=>t.smoothingTimeConstant=s)}dispose(){return super.dispose(),this._analysers.forEach(s=>s.disconnect()),this._split.dispose(),this._gain.dispose(),this}}class v extends S{constructor(){super(f(v.getDefaults(),arguments)),this.name="MeterBase",this.input=this.output=this._analyser=new P({context:this.context,size:256,type:"waveform"})}dispose(){return super.dispose(),this._analyser.dispose(),this}}class x extends v{constructor(){super(f(x.getDefaults(),arguments,["smoothing"])),this.name="Meter",this._rms=0;const s=f(x.getDefaults(),arguments,["smoothing"]);this.input=this.output=this._analyser=new P({context:this.context,size:256,type:"waveform",channels:s.channels}),this.smoothing=s.smoothing,this.normalRange=s.normalRange}static getDefaults(){return Object.assign(v.getDefaults(),{smoothing:.8,normalRange:!1,channels:1})}getLevel(){return j("'getLevel' has been changed to 'getValue'"),this.getValue()}getValue(){const s=this._analyser.getValue(),n=(this.channels===1?[s]:s).map(e=>{const r=e.reduce((i,l)=>i+l*l,0),a=Math.sqrt(r/e.length);return this._rms=Math.max(a,this._rms*this.smoothing),this.normalRange?this._rms:N(this._rms)});return this.channels===1?n[0]:n}get channels(){return this._analyser.channels}dispose(){return super.dispose(),this._analyser.dispose(),this}}const I=()=>{const o=["right","right","left","left"];return{marginRate:.2,alignments:o,boxIntervalRate:.01,boxHeightRate:.5/o.length,alphaMin:20,loopRangeLineYPosRate:.65}},J=I(),Q=(o,s)=>{s.pages[1].addInput(o,"marginRate",{step:.1,min:.1,max:1})},U="/playground/assets/track_1.043a5dc7.mp3",K="/playground/assets/track_2.ea523552.mp3",D=async o=>{const s=new q;return await s.load(o),s},E=o=>o.duration,X=(o,s,t)=>{const n=new W(o).connect(t);return n.volume.value=-5,n.loop=!0,n.loopStart=0,n.grainSize=s,n},M=async()=>{const o=await k(),s=[await D(U),await D(K)],t=[E(s[0]),E(s[1]),E(s[0]),E(s[1])],n=t.map(()=>new Y().toDestination());n.forEach((r,a)=>{r.set({pan:_.map(a,0,t.length,-1,1)})});const e=t.map((r,a)=>X(s[a%2],r,n[a]));return{se:o,panners:n,players:e,data:{durations:t}}},L=await M(),Z=(o,s,t,n)=>{n==2&&o.players.forEach(e=>e.start()),s.loopRetentionFrames.forEach((e,r)=>{e===0&&(o.panners[r].pan.value=t.panValues[r],o.players[r].reverse=s.loopIsReverses[r],o.players[r].loopStart=s.loopStartTimes[r],o.players[r].grainSize=s.loopGrainSizes[r],o.players[r].playbackRate=s.playbackRates[r])})},z=(o,s)=>{const t=o.data.durations,n=t.reduce((y,m)=>m>y?m:y,0),e=t.map(()=>0),r=t.map(y=>y),a=t.map(()=>!1),i=t.map(()=>!1),l=t.map(()=>!1),c=t.map(()=>0),p=t.map(()=>s*.001),h=t.map(()=>0),u=t.map(()=>1),g=t.map(()=>1),w=t.map(()=>new x);return o.players.forEach((y,m)=>y.connect(w[m])),{durations:t,longestDuration:n,loopStartTimes:e,loopEndTimes:r,loopIsReverses:a,loopIsSwitches:i,loopGrainSizes:r,loopIsOvers:l,loopStampTimes:c,loopElapsedTimes:p,loopProgressRates:h,loopRetentionFrames:u,playbackRates:g,volumes:w}},B=z(L,0),tt=(o,s)=>{const t={...o};return t.loopRetentionFrames=o.loopRetentionFrames.map((n,e)=>n>0?n-1:o.durations[e]*60),t.loopIsSwitches=t.loopRetentionFrames.map(n=>n===0),t.loopStartTimes=o.loopStartTimes.map((n,e)=>t.loopIsSwitches[e]?Math.random()*o.durations[e]:n),t.loopEndTimes=o.loopEndTimes.map((n,e)=>t.loopIsSwitches[e]?Math.random()*o.durations[e]:n),t.loopIsReverses=o.loopIsReverses.map((n,e)=>t.loopIsSwitches[e]?t.loopStartTimes[e]>t.loopEndTimes[e]:n),t.loopIsOvers=o.loopElapsedTimes.map((n,e)=>n>t.durations[e]/t.playbackRates[e]),t.loopStampTimes=o.loopStampTimes.map((n,e)=>t.loopIsOvers[e]?s*.001:n),t.loopElapsedTimes=o.loopElapsedTimes.map((n,e)=>s*.001-t.loopStampTimes[e]),t.loopProgressRates=t.loopElapsedTimes.map((n,e)=>n/o.durations[e]*t.playbackRates[e]),t.loopGrainSizes=t.loopEndTimes.map((n,e)=>Math.abs(n-t.loopStartTimes[e])),t.playbackRates=o.playbackRates.map((n,e)=>t.loopIsSwitches[e]?_.map(Math.random(),0,1,.5,2.5):n),t},C=(o,s,t,n)=>{const{marginRate:e}=t,a=s*(1-e)/o.longestDuration,i=n.data.durations.map(m=>m*a),l=t.alignments.map((m,d)=>{const R=s*e*.5;return m==="right"?R:s-i[d]-R}),c=n.data.durations.map((m,d)=>{const R=l[d],F=s/(n.data.durations.length+1)*(d+1);return new b.Vector().set(R,F)}),p=c.map((m,d)=>b.Vector.add(m,new b.Vector().set(i[d],0))),h=new b.Vector().set(s*t.boxIntervalRate,s*t.boxHeightRate),u=c.map((m,d)=>{const R=m.x-p[d].x;return Math.ceil(Math.abs(R/h.x))}),g=u.map((m,d)=>{const R=new b.Vector().set(0,h.y*-.5);return[b.Vector.add(c[d],R)]}),w=u.map(()=>[0]),y=c.map(m=>_.map(m.x,0,s,-1,1));return{bufferConvertRateToLength:a,fullLengths:i,margins:l,startPositions:c,endPositions:p,loopStartPositions:c,loopEndPositions:p,currentPositions:c,boxSize:h,boxNumbers:u,boxLAPositionArrays:g,boxColorArrays:w,panValues:y}};C(B,100,J,L);const st=(o,s,t,n)=>{const e={...o};return e.loopStartPositions=o.loopStartPositions.map((r,a)=>{if(!s.loopIsSwitches[a])return r;const i=r.copy(),l=s.loopStartTimes[a]/s.durations[a],p=o.fullLengths[a]*l+o.margins[a];return i.x=p,i}),e.loopEndPositions=o.loopEndPositions.map((r,a)=>{if(!s.loopIsSwitches[a])return r;const i=r.copy(),l=s.loopEndTimes[a]/s.durations[a],p=o.fullLengths[a]*l+o.margins[a];return i.x=p,i}),e.boxNumbers=o.boxNumbers.map((r,a)=>{if(!s.loopIsSwitches[a])return r;const i=e.loopStartPositions[a].x-e.loopEndPositions[a].x;return Math.ceil(Math.abs(i/o.boxSize.x))}),e.currentPositions=o.currentPositions.map((r,a)=>{const l=Math.abs(e.loopEndPositions[a].x-e.loopStartPositions[a].x)*s.loopProgressRates[a];return s.loopIsReverses[a]?(r.x=e.loopStartPositions[a].x-l,r):(r.x=e.loopStartPositions[a].x+l,r)}),e.boxLAPositionArrays=o.boxLAPositionArrays.map((r,a)=>{if(s.loopIsSwitches[a]||s.loopIsOvers[a]){const u=new b.Vector().set(0,o.boxSize.y*-.5);return[b.Vector.add(e.loopStartPositions[a],u)]}const i=s.loopIsReverses[a]?-1:1,l=r[r.length-1],c=Math.abs(e.currentPositions[a].x-l.x),p=Math.round(c/o.boxSize.x);if(p===0)return r;const h=Array.from(Array(p),(u,g)=>{const w=new b.Vector(o.boxSize.x*(g+1)*i,0);return b.Vector.add(l,w)});return r.concat(h)}),e.boxColorArrays=e.boxLAPositionArrays.map((r,a)=>{const i=o.boxColorArrays[a],l=r.length-i.length,c=s.volumes[a].getValue(),p=isFinite(c)?c:0,h=_.map(p,-50,-20,t.alphaMin,255),u=_.constrain(h,t.alphaMin,255);if(l===0)return i[i.length-1]=u,i;if(l>=1){const g=Array.from(Array(l),()=>u);return i.concat(g)}else return r.map(()=>u)}),e.panValues=e.currentPositions.map(r=>_.map(r.x,0,n,-1,1)),e},ot=(o,s,t)=>{const{startPositions:n,endPositions:e,loopStartPositions:r,loopEndPositions:a,boxLAPositionArrays:i,boxColorArrays:l,boxSize:c}=o;t.push(),t.noStroke(),i.forEach((p,h)=>{const u=l[h];p.forEach((g,w)=>{const y=u[w];t.fill(0,y),t.rect(g.x,g.y,c.x,c.y)})}),t.push(),t.noFill(),t.strokeWeight(1),t.strokeCap(t.SQUARE),t.stroke(0,100),n.forEach((p,h)=>{t.line(p.x,p.y+c.y*s.loopRangeLineYPosRate,e[h].x,e[h].y+c.y*s.loopRangeLineYPosRate)}),t.pop(),t.push(),t.noFill(),t.strokeWeight(2),t.strokeCap(t.PROJECT),t.stroke(0),r.forEach((p,h)=>{t.line(p.x,p.y+c.y*s.loopRangeLineYPosRate,a[h].x,a[h].y+c.y*s.loopRangeLineYPosRate)}),t.pop()},it=o=>{const s=_.setSize("sketch");let t=A.setController();const n=I();let e,r,a;o.setup=async()=>{a=await M(),e=z(a,o.millis()),r=C(e,s,n,a),o.createCanvas(s,s);const i=A.setGui(o,t,a.se,!1);Q(n,i),o.noLoop(),V(o,s)},o.draw=()=>{if(a===void 0){o.noLoop();return}H({status:"working"}),o.background(255),A.updateController(o,t),e=tt(e,o.millis()),r=st(r,e,n,s),ot(r,n,o),V(o,s),Z(a,e,r,o.frameCount)}};export{it as sketch};
