import{s as _,h as k,t as g,l as C,c as R,d as v}from"./tools.efdab914.js";import{G}from"./GrainPlayer.1056c040.js";import{p as m}from"./index.44744ed9.js";const I=()=>({marginRate:.2,alignments:["right","right","left","left"]}),$=I(),A=(t,o)=>{o.pages[1].addInput(t,"marginRate",{step:.1,min:.1,max:1})},b="/playground/assets/track_1.043a5dc7.mp3",f="/playground/assets/track_2.ea523552.mp3",E=async t=>{const o=new C;return await o.load(t),o},y=t=>t.duration,j=(t,o,s)=>{const a=new G(t).connect(s);return a.volume.value=-5,a.loop=!0,a.loopStart=0,a.grainSize=o,a},V=async()=>{const t=await _(),o=[await E(b),await E(f)],s=[y(o[0]),y(o[1]),y(o[0]),y(o[1])],a=s.map(()=>new k().toDestination());a.forEach((e,n)=>{e.set({pan:g.map(n,0,s.length,-1,1)})});const p=s.map((e,n)=>j(o[n%2],e,a[n]));return{se:t,panners:a,players:p,data:{durations:s}}},T=await V(),z=(t,o,s,a)=>{a==2&&t.players.forEach(p=>p.start()),o.loopRetentionFrames.forEach((p,e)=>{p===0&&(t.panners[e].pan.value=s.panValues[e],t.players[e].reverse=o.loopIsReverses[e],t.players[e].loopStart=o.loopStartTimes[e],t.players[e].grainSize=o.loopGrainSizes[e],t.players[e].playbackRate=o.playbackRates[e])})},M=t=>{const o=t.data.durations,s=o.reduce((r,l)=>l>r?l:r,0),a=o.map(()=>0),p=o.map(r=>r),e=o.map(()=>!1),n=o.map(()=>!1),i=o.map(()=>1),u=o.map(()=>1);return{durations:o,longestDuration:s,loopStartTimes:a,loopEndTimes:p,loopIsReverses:e,loopIsSwitches:n,loopGrainSizes:p,loopRetentionFrames:i,playbackRates:u}},D=M(T),O=t=>{const o={...t};return o.loopRetentionFrames=t.loopRetentionFrames.map((s,a)=>s>0?s-1:t.durations[a]*60),o.loopIsSwitches=o.loopRetentionFrames.map(s=>s===0),o.loopStartTimes=t.loopStartTimes.map((s,a)=>o.loopIsSwitches[a]?Math.random()*t.durations[a]:s),o.loopEndTimes=t.loopEndTimes.map((s,a)=>o.loopIsSwitches[a]?Math.random()*t.durations[a]:s),o.loopIsReverses=t.loopIsReverses.map((s,a)=>o.loopIsSwitches[a]?o.loopStartTimes[a]>o.loopEndTimes[a]:s),o.loopGrainSizes=o.loopEndTimes.map((s,a)=>Math.abs(s-o.loopStartTimes[a])),o.playbackRates=t.playbackRates.map((s,a)=>o.loopIsSwitches[a]?g.map(Math.random(),0,1,.5,2.5):s),o},L=(t,o,s,a)=>{const{marginRate:p}=s,n=o*(1-p)/t.longestDuration,i=a.data.durations.map(c=>c*n),u=s.alignments.map((c,d)=>{const h=o*p*.5;return c==="right"?h:o-i[d]-h}),r=a.data.durations.map((c,d)=>{const h=u[d],F=o/(a.data.durations.length+1)*(d+1);return new m.Vector().set(h,F)}),l=r.map((c,d)=>m.Vector.add(c,new m.Vector().set(i[d],0))),P=r.map(c=>g.map(c.x,0,o,-1,1)),w=o*.03,S={forward:{upperPositions:l.map(c=>m.Vector.add(c,m.Vector.fromAngle(3/4*Math.PI,w))),lowerPositions:l.map(c=>m.Vector.add(c,m.Vector.fromAngle(-3/4*Math.PI,w)))},reverse:{upperPositions:r.map(c=>m.Vector.add(c,m.Vector.fromAngle(1/4*Math.PI,w))),lowerPositions:r.map(c=>m.Vector.add(c,m.Vector.fromAngle(-1/4*Math.PI,w)))}};return{bufferConvertRateToLength:n,fullLengths:i,margins:u,startPositions:r,endPositions:l,loopStartPositions:r,loopEndPositions:l,currentPositions:r,arrowPositions:S,panValues:P}};L(D,100,$,T);const q=(t,o,s,a)=>{const p={...t};return p.loopStartPositions=t.loopStartPositions.map((e,n)=>{if(!o.loopIsSwitches[n])return e;const i=e.copy(),u=o.loopStartTimes[n]/o.durations[n],l=t.fullLengths[n]*u+t.margins[n];return i.x=l,i}),p.loopEndPositions=t.loopEndPositions.map((e,n)=>{if(!o.loopIsSwitches[n])return e;const i=e.copy(),u=o.loopEndTimes[n]/o.durations[n],l=t.fullLengths[n]*u+t.margins[n];return i.x=l,i}),p.currentPositions=t.currentPositions.map((e,n)=>{const i=m.Vector.dist(p.loopStartPositions[n],p.loopEndPositions[n]),u=o.loopIsSwitches[n]?p.loopStartPositions[n]:e,r=o.loopIsReverses[n]?-1:1,l=i/o.durations[n]/a*o.playbackRates[n]*r,P=new m.Vector().set(l,0),w=m.Vector.add(u,P);return(o.loopIsReverses[n]?w.x<t.loopEndPositions[n].x:w.x>t.loopEndPositions[n].x)?p.loopStartPositions[n]:w}),p.panValues=p.currentPositions.map(e=>g.map(e.x,0,s,-1,1)),p},H=(t,o,s)=>{const{startPositions:a,endPositions:p,loopStartPositions:e,loopEndPositions:n,arrowPositions:i,currentPositions:u}=t;s.push(),a.forEach((r,l)=>{const P=p[l];s.line(r.x,r.y,P.x,P.y)}),s.pop(),s.push(),s.fill("blue"),e.forEach(r=>{s.circle(r.x,r.y,10)}),s.pop(),s.push(),s.fill("red"),n.forEach(r=>{s.circle(r.x,r.y,10)}),s.pop(),s.pop(),p.forEach((r,l)=>{o.loopIsReverses[l]||s.line(r.x,r.y,i.forward.upperPositions[l].x,i.forward.upperPositions[l].y)}),p.forEach((r,l)=>{o.loopIsReverses[l]||s.line(r.x,r.y,i.forward.lowerPositions[l].x,i.forward.lowerPositions[l].y)}),s.push(),s.pop(),a.forEach((r,l)=>{o.loopIsReverses[l]&&s.line(r.x,r.y,i.reverse.upperPositions[l].x,i.reverse.upperPositions[l].y)}),a.forEach((r,l)=>{o.loopIsReverses[l]&&s.line(r.x,r.y,i.reverse.lowerPositions[l].x,i.reverse.lowerPositions[l].y)}),s.push(),s.pop(),u.forEach(r=>s.line(r.x,r.y-10,r.x,r.y+10)),s.push()},Q=t=>{const o=g.setSize("sketch");let s=R.setController();const a=I();let p,e,n;t.setup=async()=>{n=await V(),p=M(n),e=L(p,o,a,n),t.createCanvas(o,o);const i=R.setGui(t,s,n.se,!1);A(a,i),t.noLoop(),v(t,o)},t.draw=()=>{if(n===void 0){t.noLoop();return}t.background(255),R.updateController(t,s),p=O(p),e=q(e,p,o,t.frameRate()),H(e,p,t),v(t,o),z(n,p,e,t.frameCount)}};export{Q as sketch};
