import{t as m,s as R,D as x,d as v,c as w}from"./tools.287aac41.js";import{d as M}from"./debug.b0d6908b.js";import{p as d}from"./index.ee2e2d8c.js";const S=()=>({light:{speed:.01,shadowDistRate:4,lightDistRate:.5},boader:{angle:.45},object:{count:10},maxVolume:-10}),k=(t,n)=>{const s=n.pages[1],o=s.addFolder({title:"light"});o.addInput(t.light,"speed",{step:.001,min:.001,max:.1}),o.addInput(t.light,"shadowDistRate",{step:.1,min:1,max:1e3}),o.addInput(t.light,"lightDistRate",{step:.01,min:.01,max:2}),s.addFolder({title:"boader"}).addInput(t.boader,"angle",{step:.01,min:.01,max:1.1}),n.pages[2].addInput(t,"maxVolume",{step:1,min:-60,max:0})},V=(t,n,s)=>{const o=s===void 0,a=(()=>{if(o)return Math.PI+t.boader.angle;const u=s.angle+t.light.speed;return u>Math.PI*2?u-Math.PI*2:u})(),e=(()=>{const u=a<=t.boader.angle,h=a>=Math.PI+t.boader.angle;return u||h})(),r=o?!0:e!=s.isShadow,i=(()=>{const u=a/(Math.PI*2)-t.boader.angle/(Math.PI*2),h=u<0?1+u:u;if(e){const p=h-.5;return m.map(Math.abs(p-.25),0,.25,1,0)}return m.map(Math.abs(h-.25),0,.25,1,0)})(),c=o?new d.Vector(n*.5,n*.5):s.start,l=(()=>{const u=h=>{const p=new d.Vector(0,0);return d.Vector.dist(c,p)*h};return r||o?u(e?t.light.shadowDistRate:t.light.lightDistRate):s.length})(),g=d.Vector.fromAngle(-1*a),f=d.Vector.add(c,d.Vector.mult(g,l));return{start:c,length:l,angle:a,angleRate:i,vec:g,end:f,isShadow:e,isSwitch:r}},I=(t,n,s)=>{const o=s===void 0,a=(()=>o?!1:t.boader.angle===s.angle)();if(!o&&a)return s;const e=d.Vector.fromAngle(-1*t.boader.angle),r=n/Math.cos(t.boader.angle),i=n*Math.tan(t.boader.angle),c=(n-i)*.5,l=new d.Vector(0,c+i),g=new d.Vector(n,c);return{vec:e,length:r,start:l,end:g,angle:t.boader.angle}},b=(t,n,s,o)=>{const a=o===void 0,e=(()=>a?Array.from(Array(n.object.count),()=>Math.random()*t.length):o.intervals)(),r=e.map(g=>d.Vector.add(t.start,d.Vector.mult(t.vec,g))),i=e.map(()=>d.Vector.fromAngle(-1*n.boader.angle-Math.PI*.5)),c=(()=>a?e.map(()=>Math.random()*s*.5):o.lengths)(),l=r.map((g,f)=>d.Vector.add(g,d.Vector.mult(i[f],c[f])));return{intervals:e,starts:r,vecs:i,lengths:c,ends:l}},y=(t,n,s)=>{const o=s.starts,a=o.map((l,g)=>m.getIntersection(l,t.end,t.end,s.ends[g])),e=s.ends.map((l,g)=>m.getIntersection(l,a[g],n.start,n.end)),r=o.map((l,g)=>d.Vector.sub(a[g],l)),i=r.map(l=>d.Vector.normalize(l)),c=r.map(l=>d.Vector.mag(l));return{starts:o,ends:a,intersections:e,vecs:i,lengths:c}},D=async()=>{const t=await R();return console.log(x.get()),{se:t}},P=(t,n,s,o,a,e)=>{e.push(),e.stroke("black"),e.line(n.start.x,n.start.y,n.end.x,n.end.y),e.pop(),e.push(),e.stroke("black"),s.starts.forEach((r,i)=>{const c=s.ends[i];e.line(r.x,r.y,c.x,c.y)}),e.pop(),e.push(),e.noStroke(),o.starts.forEach((r,i)=>{const c=o.ends[i],l=o.intersections[i];e.fill(0,50*t.angleRate),e.triangle(r.x,r.y,c.x,c.y,s.ends[i].x,s.ends[i].y);const g=t.isShadow?0:255;e.fill(g,150*t.angleRate),e.triangle(r.x,r.y,c.x,c.y,l.x,l.y)}),e.pop(),v(e,a)},F=t=>{const n=m.setSize("sketch");let s=w.setController();const o=S();let a,e,r,i,c;t.setup=async()=>{c=await D(),a=V(o,n),e=I(o,n),r=b(e,o,n),i=y(a,e,r),t.createCanvas(n,n);const l=w.setGui(t,s,c.se,!1);k(o,l),t.noLoop()},t.draw=()=>{if(c===void 0){t.noLoop();return}t.frameCount%5===0&&M({angleRate:a.angleRate},10),w.updateController(t,s),a=V(o,n,a),e=I(o,n,e),r=b(e,o,n,r),i=y(a,e,r),a.isShadow&&t.background(255,200*a.angleRate),a.isShadow||t.background(100,200*a.angleRate),P(a,e,r,i,n,t)}};export{F as sketch};
