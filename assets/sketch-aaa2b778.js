import{u as F,o as w,v as z,S as D,M as X,G as J,r as Z,w as A,k as C,x as O,T as _,E as B,A as tt,p as et,y as st,z as nt,B as ot,s as at,h as rt,t as v,l as it,c as L,d as H}from"./tools-5e3ca259.js";import{d as ut}from"./debug-31bfd284.js";import{G as lt}from"./GrainPlayer-3ef38673.js";import{S as ct}from"./Split-6f7bdd2b.js";import{p as b}from"./index-664ba731.js";class V extends F{constructor(){super(w(V.getDefaults(),arguments)),this.name="ModulationSynth";const t=w(V.getDefaults(),arguments);this._carrier=new z({context:this.context,oscillator:t.oscillator,envelope:t.envelope,onsilence:()=>this.onsilence(this),volume:-10}),this._modulator=new z({context:this.context,oscillator:t.modulation,envelope:t.modulationEnvelope,volume:-10}),this.oscillator=this._carrier.oscillator,this.envelope=this._carrier.envelope,this.modulation=this._modulator.oscillator,this.modulationEnvelope=this._modulator.envelope,this.frequency=new D({context:this.context,units:"frequency"}),this.detune=new D({context:this.context,value:t.detune,units:"cents"}),this.harmonicity=new X({context:this.context,value:t.harmonicity,minValue:0}),this._modulationNode=new J({context:this.context,gain:0}),Z(this,["frequency","harmonicity","oscillator","envelope","modulation","modulationEnvelope","detune"])}static getDefaults(){return Object.assign(F.getDefaults(),{harmonicity:3,oscillator:Object.assign(A(O.getDefaults(),[...Object.keys(C.getDefaults()),"frequency","detune"]),{type:"sine"}),envelope:Object.assign(A(B.getDefaults(),Object.keys(_.getDefaults())),{attack:.01,decay:.01,sustain:1,release:.5}),modulation:Object.assign(A(O.getDefaults(),[...Object.keys(C.getDefaults()),"frequency","detune"]),{type:"square"}),modulationEnvelope:Object.assign(A(B.getDefaults(),Object.keys(_.getDefaults())),{attack:.5,decay:0,sustain:1,release:.5})})}_triggerEnvelopeAttack(t,r){this._carrier._triggerEnvelopeAttack(t,r),this._modulator._triggerEnvelopeAttack(t,r)}_triggerEnvelopeRelease(t){return this._carrier._triggerEnvelopeRelease(t),this._modulator._triggerEnvelopeRelease(t),this}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}dispose(){return super.dispose(),this._carrier.dispose(),this._modulator.dispose(),this.frequency.dispose(),this.detune.dispose(),this.harmonicity.dispose(),this._modulationNode.dispose(),this}}class T extends V{constructor(){super(w(T.getDefaults(),arguments)),this.name="AMSynth",this._modulationScale=new tt({context:this.context}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.detune.fan(this._carrier.detune,this._modulator.detune),this._modulator.chain(this._modulationScale,this._modulationNode.gain),this._carrier.chain(this._modulationNode,this.output)}dispose(){return super.dispose(),this._modulationScale.dispose(),this}}class S extends _{constructor(){super(w(S.getDefaults(),arguments,["type","size"])),this.name="Analyser",this._analysers=[],this._buffers=[];const t=w(S.getDefaults(),arguments,["type","size"]);this.input=this.output=this._gain=new J({context:this.context}),this._split=new ct({context:this.context,channels:t.channels}),this.input.connect(this._split),et(t.channels,1);for(let r=0;r<t.channels;r++)this._analysers[r]=this.context.createAnalyser(),this._split.connect(this._analysers[r],r,0);this.size=t.size,this.type=t.type}static getDefaults(){return Object.assign(_.getDefaults(),{size:1024,smoothing:.8,type:"fft",channels:1})}getValue(){return this._analysers.forEach((t,r)=>{const n=this._buffers[r];this._type==="fft"?t.getFloatFrequencyData(n):this._type==="waveform"&&t.getFloatTimeDomainData(n)}),this.channels===1?this._buffers[0]:this._buffers}get size(){return this._analysers[0].frequencyBinCount}set size(t){this._analysers.forEach((r,n)=>{r.fftSize=t*2,this._buffers[n]=new Float32Array(t)})}get channels(){return this._analysers.length}get type(){return this._type}set type(t){st(t==="waveform"||t==="fft",`Analyser: invalid type: ${t}`),this._type=t}get smoothing(){return this._analysers[0].smoothingTimeConstant}set smoothing(t){this._analysers.forEach(r=>r.smoothingTimeConstant=t)}dispose(){return super.dispose(),this._analysers.forEach(t=>t.disconnect()),this._split.dispose(),this._gain.dispose(),this}}class x extends _{constructor(){super(w(x.getDefaults(),arguments)),this.name="MeterBase",this.input=this.output=this._analyser=new S({context:this.context,size:256,type:"waveform"})}dispose(){return super.dispose(),this._analyser.dispose(),this}}class E extends x{constructor(){super(w(E.getDefaults(),arguments,["smoothing"])),this.name="Meter",this._rms=0;const t=w(E.getDefaults(),arguments,["smoothing"]);this.input=this.output=this._analyser=new S({context:this.context,size:256,type:"waveform",channels:t.channels}),this.smoothing=t.smoothing,this.normalRange=t.normalRange}static getDefaults(){return Object.assign(x.getDefaults(),{smoothing:.8,normalRange:!1,channels:1})}getLevel(){return nt("'getLevel' has been changed to 'getValue'"),this.getValue()}getValue(){const t=this._analyser.getValue(),n=(this.channels===1?[t]:t).map(s=>{const h=s.reduce((o,m)=>o+m*m,0),i=Math.sqrt(h/s.length);return this._rms=Math.max(i,this._rms*this.smoothing),this.normalRange?this._rms:ot(this._rms)});return this.channels===1?n[0]:n}get channels(){return this._analyser.channels}dispose(){return super.dispose(),this._analyser.dispose(),this}}const Q=()=>{const e=["right","right","left","left"],r=.5/e.length;return{marginRate:.2,loopRangeLineYPosRate:1.1,alignments:e,boxIntervalRate:.01,boxHeightRate:r,easingFMin:.05,easingFMax:.5,playbackRateMin:.3,playbackRateMax:3.5,loopRetentionFrameRateMin:.3,loopRetentionFrameRateMax:2.5,amSynthVolumeMin:-40,amSynthVolumeMax:-10,amSynthNote:["G6","D7","C7","E7"],granularVolumeMin:-15,granularVolumeMax:-3,hues:[357,237],saturations:[68,68],brightnesses:[80,80],saturationRange:15,brightnessRange:65,ampRateMin:.1,ampRateMax:.9,waveLengthRateMin:.01,waveLengthRateMax:1,waveSpeedRateMin:1e-5,waveSpeedRateMax:1e-4}};Q();const ht=(e,t)=>{t.pages[1].addInput(e,"marginRate",{step:.1,min:.1,max:1})},pt="/playground/assets/track_1-043a5dc7.mp3",gt="/playground/assets/track_2-ea523552.mp3",q=async e=>{const t=new it;return await t.load(e),t},P=e=>e.duration,mt=(e,t,r)=>{const n=new lt(e).connect(r);return n.volume.value=-5,n.loop=!0,n.loopStart=0,n.grainSize=t,n},ft=e=>{const t=new T;return t.connect(e),t},k=async()=>{const e=await at(),t=[await q(pt),await q(gt)],r=[P(t[0]),P(t[1]),P(t[0]),P(t[1])],n=r.map(()=>new rt().toDestination());n.forEach((i,o)=>{i.set({pan:v.map(o,0,r.length,-1,1)})});const s=r.map((i,o)=>mt(t[o%2],i,n[o])),h=r.map((i,o)=>ft(n[o]));return{se:e,panners:n,players:s,amSynths:h,data:{durations:r}}};await k();const yt=(e,t,r,n,s)=>{s==2&&e.players.forEach(h=>h.start()),t.loopRetentionFrames.forEach((h,i)=>{e.players[i].volume.value=r.amplitudes[i],h===0&&(e.panners[i].pan.value=r.panValues[i],e.players[i].reverse=t.loopIsReverses[i],e.players[i].loopStart=t.loopStartTimes[i],e.players[i].grainSize=t.loopGrainSizes[i],e.players[i].playbackRate=t.playbackRates[i])}),t.loopIsSwitches.forEach((h,i)=>{if(h===!0){const o=v.map(t.playbackRates[i],n.playbackRateMin,n.playbackRateMax,n.amSynthVolumeMin,n.amSynthVolumeMax);e.amSynths[i].volume.value=o,e.amSynths[i].triggerAttackRelease(n.amSynthNote[i],"16n")}})},dt=e=>{const t=e.data.durations,r=t.map(()=>new E);return e.players.forEach((n,s)=>n.connect(r[s])),{durations:t,volumes:r}},j=(e,t,r,n,s)=>{const h=s.currentHeights.map(o=>{const m=v.map(o,0,n.size.y,e.granularVolumeMin,e.granularVolumeMax),a=v.constrain(m,e.granularVolumeMin,e.granularVolumeMax);return isNaN(a)?0:a}),i=r.currentPositions.map(o=>v.map(o.x,0,t,-1,1));return{amplitudes:h,panValues:i}},N=(e,t,r,n)=>{const s=n===void 0,h=e.durations.reduce((y,f)=>f>y?f:y,0),i=e.durations.map((y,f)=>{if(s||n.loopRetentionFrames[f]===0){const M=v.map(Math.random(),0,1,t.loopRetentionFrameRateMin,t.loopRetentionFrameRateMax);return y*60*Math.floor(M)}return n.loopRetentionFrames[f]-1}),o=i.map(y=>y===0),m=o.map((y,f)=>s||y?v.map(Math.random(),0,1,t.playbackRateMin,t.playbackRateMax):n.playbackRates[f]),a=e.durations.map((y,f)=>s||o[f]?Math.random()*y:n.loopStartTimes[f]),g=e.durations.map((y,f)=>s||o[f]?Math.random()*y:n.loopEndTimes[f]),c=o.map((y,f)=>s?!1:y?a[f]>g[f]:n.loopIsReverses[f]),u=o.map((y,f)=>{if(s||y||n.loopIsOvers[f])return 0;const M=n.loopStampTimes[f];return r*.001-M}),p=u.map((y,f)=>y>e.durations[f]/m[f]),l=p.map((y,f)=>s||y||o[f]?r*.001:n.loopStampTimes[f]),d=u.map((y,f)=>y/e.durations[f]*m[f]),R=g.map((y,f)=>Math.abs(y-a[f]));return{longestDuration:h,loopRetentionFrames:i,loopIsSwitches:o,playbackRates:m,loopStartTimes:a,loopEndTimes:g,loopIsReverses:c,loopElapsedTimes:u,loopIsOvers:p,loopStampTimes:l,loopProgressRates:d,loopGrainSizes:R}},$=(e,t,r,n,s)=>{const h=s===void 0,i=(()=>h?r*(1-t.marginRate)/e.longestDuration:s.bufferConvertRateToLength)(),o=(()=>h?n.durations.map(c=>c*i):s.fullLengths)(),m=(()=>h?t.alignments.map((c,u)=>{const p=r*t.marginRate*.5,l=c==="right"?p:r-o[u]-p,R=r*t.boxHeightRate*t.alignments.length,y=r-R,f=t.alignments.length+1,M=y/f;return new b.Vector(l,M)}):s.margins)(),a=(()=>h?n.durations.map((c,u)=>{const p=m[u].x,l=r*t.boxHeightRate,d=m[u].y*(u+1)+l*u;return new b.Vector(p,d)}):s.startPositions)(),g=(()=>h?a.map((c,u)=>b.Vector.add(c,new b.Vector(o[u],0))):s.endPositions)();return{bufferConvertRateToLength:i,fullLengths:o,margins:m,startPositions:a,endPositions:g}},G=(e,t,r,n,s,h)=>{const i=h===void 0,o=(()=>i?s.startPositions:h.startPositions.map((p,l)=>{if(!r.loopIsSwitches[l])return p;const d=p.copy(),R=r.loopStartTimes[l]/n.durations[l],f=s.fullLengths[l]*R+s.margins[l].x;return d.x=f,d}))(),m=(()=>i?o:h.startCurrentPositions.map((p,l)=>{const d=o[l],R=d.x-p.x;if(Math.abs(R)<1)return d;const y=v.map(r.playbackRates[l],e.playbackRateMin,e.playbackRateMax,e.easingFMin,e.easingFMax),f=new b.Vector(R*y,0);return b.Vector.add(p,f)}))(),a=(()=>i?s.endPositions:h.endPositions.map((p,l)=>{if(!r.loopIsSwitches[l])return p;const d=p.copy(),R=r.loopEndTimes[l]/n.durations[l],f=s.fullLengths[l]*R+s.margins[l].x;return d.x=f,d}))(),g=(()=>i?a:h.endCurrentPositions.map((p,l)=>{const d=a[l],R=d.x-p.x;if(Math.abs(R)<1)return d;const y=v.map(r.playbackRates[l],e.playbackRateMin,e.playbackRateMax,e.easingFMin,e.easingFMax),f=new b.Vector(R*y,0);return b.Vector.add(p,f)}))(),c=o.map((p,l)=>i?0:Math.abs(a[l].x-p.x)*r.loopProgressRates[l]),u=(()=>i?n.durations.map((p,l)=>{const d=s.margins[l].x,R=t/(n.durations.length+1)*(l+1);return new b.Vector(d,R)}):h.currentPositions.map((p,l)=>r.loopIsReverses[l]?(p.x=o[l].x-c[l],p):(p.x=o[l].x+c[l],p)))();return{startPositions:o,startCurrentPositions:m,endPositions:a,endCurrentPositions:g,progresses:c,currentPositions:u}},Y=(e,t,r,n,s)=>{const h=s===void 0,i=new b.Vector(t*e.boxIntervalRate,t*e.boxHeightRate),o=n.startPositions.map((c,u)=>{if(h||r.loopIsSwitches[u]){const p=c.x-n.endPositions[u].x,l=Math.ceil(Math.abs(p/i.x));return l<1?1:l}return s.counts[u]}),m=n.startPositions.map((c,u)=>h||r.loopIsSwitches[u]?Array.from(Array(o[u]),(p,l)=>{const d=r.loopIsReverses[u]?-1:1,R=new b.Vector(i.x*d*l,0);return b.Vector.add(c,R)}):s.positionArrays[u]),a=n.progresses.map((c,u)=>{if(h||r.loopIsSwitches[u]||r.loopIsOvers[u])return 0;const p=i.x*s.currentIndexes[u],l=Math.abs(c-p),d=Math.floor(l/i.x),R=s.currentIndexes[u]+d,y=m[u].length-1;return R>y?y:R}),g=a.map((c,u)=>h?0:c-s.currentIndexes[u]);return{size:i,counts:o,positionArrays:m,currentIndexes:a,addedSegments:g}},U=(e,t,r,n,s,h)=>{const i=h===void 0,o=e.loopIsSwitches.map((c,u)=>i||c?v.map(Math.random(),0,1,t.waveSpeedRateMin*r,t.waveSpeedRateMax*r):h.angleSpeeds[u]),m=s.positionArrays.map((c,u)=>{if(i||e.loopIsSwitches[u]){const p=Math.abs(n.endPositions[u].x-n.startPositions[u].x),l=v.map(Math.random(),0,1,t.waveLengthRateMin,t.waveLengthRateMax),d=p*l,R=p/d,f=Math.PI*2*R/s.counts[u];return c.map((M,K)=>f*K)}return h.angleArrays[u].map(p=>p+o[u])}),a=e.loopIsSwitches.map((c,u)=>i||c?v.map(Math.random(),0,1,t.ampRateMin*s.size.y,t.ampRateMax*s.size.y):h.amps[u]),g=s.positionArrays.map((c,u)=>{const p=a[u];return c.map((l,d)=>{const R=m[u][d],y=l.y+s.size.y*.5,f=v.map(Math.sin(R),-1,1,-.5,.5)*p;return new b.Vector(l.x,y+f)})});return{angleSpeeds:o,angleArrays:m,amps:a,positionArrays:g}},W=(e,t,r)=>{const n=r===void 0,s=(()=>{const m=new b.Vector(0,e.size.y);return e.positionArrays.map((a,g)=>a.filter((u,p)=>p<=e.currentIndexes[g]).map(u=>b.Vector.add(u,m)))})(),h=t.positionArrays.map((m,a)=>{const g=e.currentIndexes[a],c=m[g];return s[a][g].y-c.y}),i=s.map((m,a)=>{const g=h[a],c=e.addedSegments[a],u=m.length;if(n||c<0)return Array.from(Array(u),()=>g);const p=r.heightArrays[a];if(c===0)return p.map((d,R)=>R===p.length-1?g:d);const l=Array.from(Array(c),()=>g);return p.concat(l)}),o=s.map((m,a)=>m.map((g,c)=>{const u=new b.Vector(0,i[a][c]);return b.Vector.sub(g,u)}));return{LLpositionArrays:s,currentHeights:h,heightArrays:i,positionArrays:o}},I=(e,t,r,n,s)=>{const h=e.loopIsReverses.map(a=>{const g=a?0:1;return t.hues[g]}),i=e.loopIsReverses.map((a,g)=>{const c=a?1:0,u=t.saturations[c];return v.map(e.playbackRates[g],t.playbackRateMin,t.playbackRateMax,u-t.saturationRange,u+t.saturationRange)}),o=e.loopIsReverses.map(a=>{const g=a?1:0;return t.brightnesses[g]}),m=n.positionArrays.map((a,g)=>{const c=r.volumes[g].getValue(),u=isFinite(c)?c:0,p=v.map(u,-50,-20,o[g]-t.brightnessRange,o[g]+t.brightnessRange),l=v.constrain(p,o[g]-t.brightnessRange,o[g]+t.brightnessRange);if(s===void 0||e.loopIsOvers[g]||e.loopIsSwitches[g])return a.map(()=>l);const d=s.brightnessArrays[g],R=a.length-d.length;if(R===0)return d[d.length-1]=l,d;const y=Array.from(Array(R),()=>l);return d.concat(y)});return{hues:h,saturations:i,brightnesses:o,brightnessArrays:m}},Rt=(e,t,r,n,s,h,i,o)=>{o.push(),o.noFill(),o.strokeWeight(1),o.strokeCap(o.SQUARE),e.startPositions.forEach((m,a)=>{o.stroke(s.hues[a],s.saturations[a],s.brightnesses[a]),o.line(m.x,m.y+h.size.y*i.loopRangeLineYPosRate,e.endPositions[a].x,e.endPositions[a].y+h.size.y*i.loopRangeLineYPosRate)}),o.strokeWeight(3),o.strokeCap(o.PROJECT),t.startCurrentPositions.forEach((m,a)=>{o.push(),o.stroke(s.hues[a],s.saturations[a],s.brightnesses[a]),o.line(m.x,m.y+h.size.y*i.loopRangeLineYPosRate,t.endCurrentPositions[a].x,t.endCurrentPositions[a].y+h.size.y*i.loopRangeLineYPosRate),o.pop()}),o.pop(),o.push(),r.positionArrays.forEach((m,a)=>{const g=h.currentIndexes[a];o.stroke(s.hues[a],s.saturations[a],s.brightnesses[a]),m.forEach((c,u)=>{u>g&&o.line(c.x,c.y,c.x+h.size.x,c.y)})}),o.pop(),o.push(),o.noStroke(),n.positionArrays.forEach((m,a)=>{const g=s.hues[a],c=s.brightnessArrays[a],u=s.saturations[a],p=n.heightArrays[a];m.forEach((l,d)=>{const R=p[d],y=c[d];o.fill(g,y,u),o.rect(l.x,l.y,h.size.x,R)})}),o.pop()},St=e=>{const t=v.setSize("sketch");let r=L.setController();const n=Q();let s,h,i,o,m,a,g,c,u,p;e.setup=async()=>{h=await k(),i=dt(h),s=N(i,n,e.millis()),m=$(s,n,t,i),a=G(n,t,s,i,m),g=Y(n,t,s,a),c=U(s,n,t,a,g),u=W(g,c),p=I(s,n,i,g,p),o=j(n,t,a,g,u),e.createCanvas(t,t);const l=L.setGui(e,r,h.se,!1);ht(n,l),e.colorMode(e.HSB),e.noLoop(),H(e,t)},e.draw=()=>{if(h===void 0){e.noLoop();return}e.frameCount%5===0&&ut({na:"working"},10),e.background(255),L.updateController(e,r),s=N(i,n,e.millis(),s),m=$(s,n,t,i,m),a=G(n,t,s,i,m,a),g=Y(n,t,s,a,g),c=U(s,n,t,a,g,c),u=W(g,c,u),p=I(s,n,i,g,p),o=j(n,t,a,g,u),Rt(m,a,c,u,p,g,n,e),H(e,t),yt(h,s,o,n,e.frameCount)}};export{St as sketch};
