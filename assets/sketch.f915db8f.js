import{t as x,c as V,d as F}from"./tools.88b38d76.js";import{p as c}from"./index.28ccc2d8.js";const P=()=>({num:10,gravity:9.8,windF:5,massMin:10,massMax:20,velXmax:5,velYmax:5,bufferRate:.95,bufferRateMin:.9,fontSizeRate:.007}),b=P(),S=(t,e)=>{const s=e.pages[1];s.addInput(t,"windF",{min:0,max:10}),s.addInput(t,"bufferRate",{min:t.bufferRateMin,max:1.1})},p=(t,e)=>{const{num:s,gravity:n,massMin:u,massMax:m,velXmax:r,velYmax:o}=t;return{movers:Array.from(Array(s),()=>{const a=x.map(Math.random(),0,1,u,m),w=(()=>{const i=Math.random()*r,d=Math.random()*o;return new c.Vector().set(i,d)})();return{mass:a,gravityAcc:new c.Vector().set(0,n/a),initVel:w,acc:new c.Vector().set(0,0),windAcc:new c.Vector().set(0,0),vel:w,pos:(()=>{const i=Math.random()*e,d=Math.random()*e;return new c.Vector().set(i,d)})()}})}};p(b,100);const j=(t,e,s)=>{const{windF:n,bufferRate:u}=e,m={...t};return m.movers=t.movers.map(r=>{const o={...r};o.windAcc=new c.Vector(n/r.mass,0),o.acc=(()=>{const f=r.gravityAcc,i=o.windAcc;return c.Vector.add(f,i)})();const a=f=>c.Vector.add(r.pos,f),w=(f,i)=>{const d=c.Vector.add(r.vel,o.acc),l=f?d.x*-1*u:d.x,R=i?d.y*-1*u:d.y;return new c.Vector().set(l,R)};return o.vel=(()=>{const f=w(!1,!1),i=a(f),d=i.x<0||i.x>s,l=i.y>s;return w(d,l)})(),o.pos=(()=>{const f=a(o.vel),i=d=>d==="x"&&f[d]<0?0:f[d]>s?s:f[d];return new c.Vector().set(i("x"),i("y"))})(),o}),m},C=(t,e,s,n)=>{const{fontSizeRate:u}=e;n.push();let m=0;for(const r of t.movers){const{pos:o,mass:a}=r;n.textSize(s*u*a),n.text(m,o.x,o.y),m++}n.pop()},v={setParams:P,setGui:S,setData:p,updateData:j,draw:C},D=t=>({num:t.num,lengthMin:10,lengthMax:30,gravityRate:2,windRate:10,bufferAdjustRate:5,bufferBaseRate:.1}),I=D(b),X=(t,e)=>{e.pages[1].addInput(t,"gravityRate",{step:.5,min:1,max:5})},A=(t,e)=>{const{num:s,lengthMin:n,lengthMax:u}=t;return{winds:Array.from(Array(s),()=>{const m=(()=>{const o=Math.random()*e,a=Math.random()*e;return new c.Vector().set(o,a)})();return{length:x.map(Math.random(),0,1,n,u),vec:new c.Vector().set(0,0),startPos:m,endPos:m,isReset:!1}})}};A(I,100);const Y=(t,e,s,n,u)=>{const m={...t};return m.winds=t.winds.map((r,o)=>{const a={...r},w=e.movers[o],{lengthMin:f,lengthMax:i,gravityRate:d,windRate:l,bufferAdjustRate:R,bufferBaseRate:k}=s,{bufferRate:M,bufferRateMin:G}=n;return a.vec=(()=>{const g=(M-G+k)*R,y=c.Vector.mult(w.acc,M*g),$=new c.Vector().set(l,d);return c.Vector.mult(y,$)})(),a.length=(()=>r.isReset?x.map(Math.random(),0,1,f,i):r.length-c.Vector.mag(a.vec))(),a.isReset=(()=>r.isReset?!1:a.length<0)(),a.startPos=(()=>{if(a.isReset){const g=Math.random()*u,y=Math.random()*u;return new c.Vector().set(g,y)}return r.startPos})(),a.endPos=(()=>a.isReset?a.startPos:c.Vector.add(r.endPos,a.vec))(),a}),m},_=(t,e)=>{e.push(),e.strokeWeight(3),e.stroke(0,60);for(const s of t.winds){const{startPos:n,endPos:u}=s;e.line(n.x,n.y,u.x,u.y)}e.pop()},h={setParams:D,setGui:X,setData:A,updateData:Y,draw:_},L=t=>{const e=x.setSize("sketch");let s=V.setController();const n=v.setParams(),u=h.setParams(n);let m=v.setData(n,e),r=h.setData(u,e);t.setup=()=>{t.createCanvas(e,e);const o=V.setGui(t,s,!1,!1);v.setGui(n,o),h.setGui(u,o),t.noLoop()},t.draw=()=>{t.background(255),V.updateController(t,s),m=v.updateData(m,n,e),r=h.updateData(r,m,u,n,e),v.draw(m,n,e,t),h.draw(r,t),F(t,e)}};export{L as sketch};
