import{u as X,o as S,v as W,S as J,M as at,G as B,r as it,w as I,k as Q,x as U,T,E as K,A as rt,p as lt,y as ct,z as ut,B as pt,s as ht,h as gt,t as m,l as mt,c as G,d as Z}from"./tools.62996705.js";import{d as yt}from"./debug.9b50b263.js";import{G as dt}from"./GrainPlayer.ff51f496.js";import{p as R}from"./index.293da30f.js";class C extends X{constructor(){super(S(C.getDefaults(),arguments)),this.name="ModulationSynth";const t=S(C.getDefaults(),arguments);this._carrier=new W({context:this.context,oscillator:t.oscillator,envelope:t.envelope,onsilence:()=>this.onsilence(this),volume:-10}),this._modulator=new W({context:this.context,oscillator:t.modulation,envelope:t.modulationEnvelope,volume:-10}),this.oscillator=this._carrier.oscillator,this.envelope=this._carrier.envelope,this.modulation=this._modulator.oscillator,this.modulationEnvelope=this._modulator.envelope,this.frequency=new J({context:this.context,units:"frequency"}),this.detune=new J({context:this.context,value:t.detune,units:"cents"}),this.harmonicity=new at({context:this.context,value:t.harmonicity,minValue:0}),this._modulationNode=new B({context:this.context,gain:0}),it(this,["frequency","harmonicity","oscillator","envelope","modulation","modulationEnvelope","detune"])}static getDefaults(){return Object.assign(X.getDefaults(),{harmonicity:3,oscillator:Object.assign(I(U.getDefaults(),[...Object.keys(Q.getDefaults()),"frequency","detune"]),{type:"sine"}),envelope:Object.assign(I(K.getDefaults(),Object.keys(T.getDefaults())),{attack:.01,decay:.01,sustain:1,release:.5}),modulation:Object.assign(I(U.getDefaults(),[...Object.keys(Q.getDefaults()),"frequency","detune"]),{type:"square"}),modulationEnvelope:Object.assign(I(K.getDefaults(),Object.keys(T.getDefaults())),{attack:.5,decay:0,sustain:1,release:.5})})}_triggerEnvelopeAttack(t,o){this._carrier._triggerEnvelopeAttack(t,o),this._modulator._triggerEnvelopeAttack(t,o)}_triggerEnvelopeRelease(t){return this._carrier._triggerEnvelopeRelease(t),this._modulator._triggerEnvelopeRelease(t),this}getLevelAtTime(t){return t=this.toSeconds(t),this.envelope.getValueAtTime(t)}dispose(){return super.dispose(),this._carrier.dispose(),this._modulator.dispose(),this.frequency.dispose(),this.detune.dispose(),this.harmonicity.dispose(),this._modulationNode.dispose(),this}}class $ extends C{constructor(){super(S($.getDefaults(),arguments)),this.name="AMSynth",this._modulationScale=new rt({context:this.context}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.detune.fan(this._carrier.detune,this._modulator.detune),this._modulator.chain(this._modulationScale,this._modulationNode.gain),this._carrier.chain(this._modulationNode,this.output)}dispose(){return super.dispose(),this._modulationScale.dispose(),this}}class j extends T{constructor(){super(S(j.getDefaults(),arguments,["channels"])),this.name="Split";const t=S(j.getDefaults(),arguments,["channels"]);this._splitter=this.input=this.output=this.context.createChannelSplitter(t.channels),this._internalChannels=[this._splitter]}static getDefaults(){return Object.assign(T.getDefaults(),{channels:2})}dispose(){return super.dispose(),this._splitter.disconnect(),this}}class L extends T{constructor(){super(S(L.getDefaults(),arguments,["type","size"])),this.name="Analyser",this._analysers=[],this._buffers=[];const t=S(L.getDefaults(),arguments,["type","size"]);this.input=this.output=this._gain=new B({context:this.context}),this._split=new j({context:this.context,channels:t.channels}),this.input.connect(this._split),lt(t.channels,1);for(let o=0;o<t.channels;o++)this._analysers[o]=this.context.createAnalyser(),this._split.connect(this._analysers[o],o,0);this.size=t.size,this.type=t.type}static getDefaults(){return Object.assign(T.getDefaults(),{size:1024,smoothing:.8,type:"fft",channels:1})}getValue(){return this._analysers.forEach((t,o)=>{const n=this._buffers[o];this._type==="fft"?t.getFloatFrequencyData(n):this._type==="waveform"&&t.getFloatTimeDomainData(n)}),this.channels===1?this._buffers[0]:this._buffers}get size(){return this._analysers[0].frequencyBinCount}set size(t){this._analysers.forEach((o,n)=>{o.fftSize=t*2,this._buffers[n]=new Float32Array(t)})}get channels(){return this._analysers.length}get type(){return this._type}set type(t){ct(t==="waveform"||t==="fft",`Analyser: invalid type: ${t}`),this._type=t}get smoothing(){return this._analysers[0].smoothingTimeConstant}set smoothing(t){this._analysers.forEach(o=>o.smoothingTimeConstant=t)}dispose(){return super.dispose(),this._analysers.forEach(t=>t.disconnect()),this._split.dispose(),this._gain.dispose(),this}}class H extends T{constructor(){super(S(H.getDefaults(),arguments)),this.name="MeterBase",this.input=this.output=this._analyser=new L({context:this.context,size:256,type:"waveform"})}dispose(){return super.dispose(),this._analyser.dispose(),this}}class q extends H{constructor(){super(S(q.getDefaults(),arguments,["smoothing"])),this.name="Meter",this._rms=0;const t=S(q.getDefaults(),arguments,["smoothing"]);this.input=this.output=this._analyser=new L({context:this.context,size:256,type:"waveform",channels:t.channels}),this.smoothing=t.smoothing,this.normalRange=t.normalRange}static getDefaults(){return Object.assign(H.getDefaults(),{smoothing:.8,normalRange:!1,channels:1})}getLevel(){return ut("'getLevel' has been changed to 'getValue'"),this.getValue()}getValue(){const t=this._analyser.getValue(),n=(this.channels===1?[t]:t).map(i=>{const e=i.reduce((r,l)=>r+l*l,0),s=Math.sqrt(e/i.length);return this._rms=Math.max(s,this._rms*this.smoothing),this.normalRange?this._rms:pt(this._rms)});return this.channels===1?n[0]:n}get channels(){return this._analyser.channels}dispose(){return super.dispose(),this._analyser.dispose(),this}}const tt=()=>{const a=["right","right","left","left"];return{marginRate:.2,alignments:a,boxIntervalRate:.01,boxHeightRate:.5/a.length,easingFMin:.05,easingFMax:.5,playbackRateMin:.3,playbackRateMax:3.5,loopRetentionFrameRateMin:.3,loopRetentionFrameRateMax:2.5,amSynthVolumeMin:-40,amSynthVolumeMax:-10,amSynthNote:["G6","D7","C7","E7"],granularVolumeMin:-15,granularVolumeMax:-3,hues:[357,237],saturations:[68,68],brightnesses:[80,80],saturationRange:15,brightnessRange:65,loopRangeLineYPosRate:.65,ampRateMin:.1,ampRateMax:.9,waveLengthRateMin:.01,waveLengthRateMax:10,waveSpeedRateMin:1e-5,waveSpeedRateMax:1e-4}},Rt=tt(),vt=(a,t)=>{t.pages[1].addInput(a,"marginRate",{step:.1,min:.1,max:1})},bt="/playground/assets/track_1.043a5dc7.mp3",wt="/playground/assets/track_2.ea523552.mp3",k=async a=>{const t=new mt;return await t.load(a),t},N=a=>a.duration,xt=(a,t,o)=>{const n=new dt(a).connect(o);return n.volume.value=-5,n.loop=!0,n.loopStart=0,n.grainSize=t,n},At=a=>{const t=new $;return t.connect(a),t},st=async()=>{const a=await ht(),t=[await k(bt),await k(wt)],o=[N(t[0]),N(t[1]),N(t[0]),N(t[1])],n=o.map(()=>new gt().toDestination());n.forEach((s,r)=>{s.set({pan:m.map(r,0,o.length,-1,1)})});const i=o.map((s,r)=>xt(t[r%2],s,n[r])),e=o.map((s,r)=>At(n[r]));return{se:a,panners:n,players:i,amSynths:e,data:{durations:o}}},ot=await st(),Mt=(a,t,o,n,i)=>{i==2&&a.players.forEach(e=>e.start()),t.loopRetentionFrames.forEach((e,s)=>{a.players[s].volume.value=o.amplitudes[s],e===0&&(a.panners[s].pan.value=o.panValues[s],a.players[s].reverse=t.loopIsReverses[s],a.players[s].loopStart=t.loopStartTimes[s],a.players[s].grainSize=t.loopGrainSizes[s],a.players[s].playbackRate=t.playbackRates[s])}),t.loopIsSwitches.forEach((e,s)=>{if(e===!0){const r=m.map(t.playbackRates[s],n.playbackRateMin,n.playbackRateMax,n.amSynthVolumeMin,n.amSynthVolumeMax);a.amSynths[s].volume.value=r,a.amSynths[s].triggerAttackRelease(n.amSynthNote[s],"16n")}})},et=(a,t)=>{const o=a.data.durations,n=o.reduce((x,P)=>P>x?P:x,0),i=o.map(()=>0),e=o.map(x=>x),s=o.map(()=>!1),r=o.map(()=>!1),l=o.map(()=>!1),c=o.map(()=>0),u=o.map(()=>t*.001),v=o.map(()=>0),p=o.map(()=>1),y=o.map(()=>1),w=o.map(()=>new q);return a.players.forEach((x,P)=>x.connect(w[P])),{durations:o,longestDuration:n,loopStartTimes:i,loopEndTimes:e,loopIsReverses:s,loopIsSwitches:r,loopGrainSizes:e,loopIsOvers:l,loopStampTimes:c,loopElapsedTimes:u,loopProgressRates:v,loopRetentionFrames:p,playbackRates:y,volumes:w}},_t=et(ot,0),Pt=(a,t,o)=>{const n={...a};return n.loopRetentionFrames=a.loopRetentionFrames.map((i,e)=>{if(i>0)return i-1;const s=m.map(Math.random(),0,1,t.loopRetentionFrameRateMin,t.loopRetentionFrameRateMax);return a.durations[e]*60*Math.floor(s)}),n.loopIsSwitches=n.loopRetentionFrames.map(i=>i===0),n.loopStartTimes=a.loopStartTimes.map((i,e)=>n.loopIsSwitches[e]?Math.random()*a.durations[e]:i),n.loopEndTimes=a.loopEndTimes.map((i,e)=>n.loopIsSwitches[e]?Math.random()*a.durations[e]:i),n.loopIsReverses=a.loopIsReverses.map((i,e)=>n.loopIsSwitches[e]?n.loopStartTimes[e]>n.loopEndTimes[e]:i),n.loopIsOvers=a.loopElapsedTimes.map((i,e)=>i>n.durations[e]/n.playbackRates[e]),n.loopStampTimes=a.loopStampTimes.map((i,e)=>n.loopIsOvers[e]?o*.001:i),n.loopElapsedTimes=a.loopElapsedTimes.map((i,e)=>o*.001-n.loopStampTimes[e]),n.loopProgressRates=n.loopElapsedTimes.map((i,e)=>i/a.durations[e]*n.playbackRates[e]),n.loopGrainSizes=n.loopEndTimes.map((i,e)=>Math.abs(i-n.loopStartTimes[e])),n.playbackRates=a.playbackRates.map((i,e)=>n.loopIsSwitches[e]?m.map(Math.random(),0,1,t.playbackRateMin,t.playbackRateMax):i),n},nt=(a,t,o,n)=>{const{marginRate:i}=o,s=t*(1-i)/a.longestDuration,r=n.data.durations.map(h=>h*s),l=o.alignments.map((h,d)=>{const _=t*i*.5;return h==="right"?_:t-r[d]-_}),c=n.data.durations.map((h,d)=>{const _=l[d],Y=t/(n.data.durations.length+1)*(d+1);return new R.Vector(_,Y)}),u=n.data.durations.map((h,d)=>{const _=l[d],Y=t/(n.data.durations.length+1)*(d+1);return new R.Vector(_,Y)}),v=c.map((h,d)=>R.Vector.add(h,new R.Vector().set(r[d],0))),p=new R.Vector(t*o.boxIntervalRate,t*o.boxHeightRate),y=c.map((h,d)=>{const _=h.x-v[d].x;return Math.ceil(Math.abs(_/p.x))}),w=c.map(h=>Array.from(Array(y),()=>h.x)),x=y.map(()=>0),P=w.map(h=>h.map(()=>0)),M=y.map(()=>0),g=P.map((h,d)=>h.map(()=>c[d].y)),b=y.map((h,d)=>{const _=new R.Vector(0,p.y*-.5);return[R.Vector.add(c[d],_)]}),A=y.map(()=>0),E=y.map(()=>0),f=b.map(h=>h.map(()=>0)),D=A.map(()=>0),O=a.loopIsReverses.map(()=>0),V=a.loopIsReverses.map(()=>0),F=a.loopIsReverses.map(()=>[0]),z=c.map(h=>m.map(h.x,0,t,-1,1));return{bufferConvertRateToLength:s,fullLengths:r,margins:l,startPositions:c,endPositions:v,loopStartPositions:c,loopStartCurrentPositions:c,loopEndPositions:v,loopEndCurrentPositions:v,currentPositions:u,boxSize:p,boxNumbers:y,waveXPositionArrays:w,waveAngleSpeeds:x,waveAngleArrays:P,waveAmps:M,waveYPositionArrays:g,boxLAPositionArrays:b,currentBoxIndexes:A,currentBoxHeightOffsets:E,boxHeightOffsetArrays:f,amplitudes:D,boxHues:O,boxSaturations:V,boxBrightnessArrays:F,panValues:z}};nt(_t,100,Rt,ot);const St=(a,t,o,n)=>{const i={...a};return i.loopStartPositions=a.loopStartPositions.map((e,s)=>{if(!t.loopIsSwitches[s])return e;const r=e.copy(),l=t.loopStartTimes[s]/t.durations[s],u=a.fullLengths[s]*l+a.margins[s];return r.x=u,r}),i.loopStartCurrentPositions=a.loopStartCurrentPositions.map((e,s)=>{const r=i.loopStartPositions[s],l=r.x-e.x;if(Math.abs(l)<1)return r;const c=m.map(t.playbackRates[s],o.playbackRateMin,o.playbackRateMax,o.easingFMin,o.easingFMax),u=new R.Vector(l*c,0);return R.Vector.add(e,u)}),i.loopEndPositions=a.loopEndPositions.map((e,s)=>{if(!t.loopIsSwitches[s])return e;const r=e.copy(),l=t.loopEndTimes[s]/t.durations[s],u=a.fullLengths[s]*l+a.margins[s];return r.x=u,r}),i.loopEndCurrentPositions=a.loopEndCurrentPositions.map((e,s)=>{const r=i.loopEndPositions[s],l=r.x-e.x;if(Math.abs(l)<1)return r;const c=m.map(t.playbackRates[s],o.playbackRateMin,o.playbackRateMax,o.easingFMin,o.easingFMax),u=new R.Vector(l*c,0);return R.Vector.add(e,u)}),i.boxNumbers=a.boxNumbers.map((e,s)=>{if(!t.loopIsSwitches[s])return e;const r=i.loopStartPositions[s].x-i.loopEndPositions[s].x;return Math.ceil(Math.abs(r/a.boxSize.x))}),i.waveXPositionArrays=a.waveXPositionArrays.map((e,s)=>{if(!t.loopIsSwitches[s])return e;const r=i.boxNumbers[s],l=t.loopIsReverses[s]?-1:1,c=i.loopStartPositions[s];return Array.from(Array(r),(u,v)=>c.x+a.boxSize.x*v*l)}),i.waveAngleSpeeds=a.waveAngleSpeeds.map((e,s)=>t.loopIsSwitches[s]?m.map(Math.random(),0,1,o.waveSpeedRateMin*n,o.waveSpeedRateMax*n):e),i.waveAngleArrays=a.waveAngleArrays.map((e,s)=>{if(!t.loopIsSwitches[s])return e.map(c=>c+i.waveAngleSpeeds[s]);const r=i.waveXPositionArrays[s],l=Math.abs(i.loopEndPositions[s].x-i.loopStartPositions[s].x)*m.map(Math.random(),0,1,o.waveLengthRateMin,o.waveLengthRateMax);return r.map(c=>{const u=l/i.boxNumbers[s];return c/u*Math.PI*2})}),i.waveAmps=a.waveAmps.map((e,s)=>t.loopIsSwitches[s]?m.map(Math.random(),0,1,o.ampRateMin*a.boxSize.y,o.ampRateMax*a.boxSize.y):e),i.waveYPositionArrays=i.waveAngleArrays.map((e,s)=>{const r=i.waveAmps[s],l=a.startPositions[s].y;return e.map(c=>m.map(Math.sin(c),-1,1,0,1)*r+l)}),i.currentPositions=a.currentPositions.map((e,s)=>{const l=Math.abs(i.loopEndPositions[s].x-i.loopStartPositions[s].x)*t.loopProgressRates[s];return t.loopIsReverses[s]?(e.x=i.loopStartPositions[s].x-l,e):(e.x=i.loopStartPositions[s].x+l,e)}),i.boxLAPositionArrays=a.boxLAPositionArrays.map((e,s)=>{if(t.loopIsSwitches[s]||t.loopIsOvers[s]){const p=new R.Vector().set(0,a.boxSize.y*-.5);return[R.Vector.add(i.loopStartPositions[s],p)]}const r=t.loopIsReverses[s]?-1:1,l=e[e.length-1],c=Math.abs(i.currentPositions[s].x-l.x),u=Math.round(c/a.boxSize.x);if(u===0)return e;const v=Array.from(Array(u),(p,y)=>{const w=new R.Vector(a.boxSize.x*(y+1)*r,0);return R.Vector.add(l,w)});return e.concat(v)}),i.currentBoxIndexes=i.boxLAPositionArrays.map(e=>e.length-1),i.currentBoxHeightOffsets=i.waveYPositionArrays.map((e,s)=>{const r=i.currentBoxIndexes[s],l=i.waveYPositionArrays[s][r],c=a.startPositions[s].y;return l-c}),i.boxHeightOffsetArrays=a.boxHeightOffsetArrays.map((e,s)=>{const r=i.boxLAPositionArrays[s].length,l=a.boxLAPositionArrays[s].length,c=r-l;if(c===0)return e[e.length-1]=i.currentBoxHeightOffsets[s],e;if(c<0)return Array.from(Array(r),()=>i.currentBoxHeightOffsets[s]);{const u=Array.from(Array(c),()=>i.currentBoxHeightOffsets[s]);return e.concat(u)}}),i.amplitudes=i.currentBoxHeightOffsets.map(e=>{const s=m.map(e,0,a.boxSize.y,o.granularVolumeMin,o.granularVolumeMax),r=m.constrain(s,o.granularVolumeMin,o.granularVolumeMax);return isNaN(r)?0:r}),i.boxHues=t.loopIsReverses.map(e=>{const s=e?0:1;return o.hues[s]}),i.boxSaturations=t.loopIsReverses.map((e,s)=>{const r=e?1:0,l=o.saturations[r];return m.map(t.playbackRates[s],o.playbackRateMin,o.playbackRateMax,l-o.saturationRange,l+o.saturationRange)}),i.boxBrightnessArrays=i.boxLAPositionArrays.map((e,s)=>{const r=a.boxBrightnessArrays[s],l=e.length-r.length,c=t.volumes[s].getValue(),u=isFinite(c)?c:0,v=t.loopIsReverses[s]?1:0,p=o.brightnesses[v],y=m.map(u,-50,-20,p-o.brightnessRange,p+o.brightnessRange),w=m.constrain(y,p-o.brightnessRange,p+o.brightnessRange);if(l===0)return r[r.length-1]=w,r;if(l>=1){const x=Array.from(Array(l),()=>w);return r.concat(x)}else return e.map(()=>w)}),i.panValues=i.currentPositions.map(e=>m.map(e.x,0,n,-1,1)),i},Et=(a,t,o,n)=>{const{startPositions:i,endPositions:e,loopStartCurrentPositions:s,loopEndCurrentPositions:r,boxLAPositionArrays:l,boxHues:c,boxSaturations:u,boxBrightnessArrays:v,boxSize:p,waveXPositionArrays:y,waveYPositionArrays:w,boxHeightOffsetArrays:x,currentBoxIndexes:P}=a;n.push(),n.noStroke(),l.forEach((M,g)=>{const b=c[g],A=v[g],E=u[g],f=x[g];M.forEach((D,O)=>{const V=f[O],F=A[O];n.fill(b,F,E),n.rect(D.x,D.y+p.y-V,p.x,V)})}),n.pop(),n.push(),n.noFill(),n.strokeWeight(1),n.strokeCap(n.SQUARE),i.forEach((M,g)=>{const b=t.loopIsReverses[g]?0:1,A=o.hues[b],E=o.saturations[b]-o.saturationRange,f=o.saturations[b]-o.brightnessRange*.5;n.stroke(A,E,f),n.line(M.x,M.y+p.y*o.loopRangeLineYPosRate,e[g].x,e[g].y+p.y*o.loopRangeLineYPosRate)}),n.strokeWeight(3),n.strokeCap(n.PROJECT),s.forEach((M,g)=>{n.push();const b=t.loopIsReverses[g]?0:1,A=o.hues[b],E=o.saturations[b]-o.saturationRange,f=o.saturations[b]-o.brightnessRange*.5;n.stroke(A,E,f),n.line(M.x,M.y+p.y*o.loopRangeLineYPosRate,r[g].x,r[g].y+p.y*o.loopRangeLineYPosRate),n.pop()}),n.pop(),n.push(),y.forEach((M,g)=>{const b=P[g],A=t.loopIsReverses[g]?0:1,E=o.hues[A],f=o.saturations[A]-o.saturationRange,D=o.saturations[A]-o.brightnessRange*.5;n.stroke(E,f,D);const O=w[g];M.forEach((V,F)=>{if(F>b){const z=O[F];n.line(V,z,V+p.x,z)}})}),n.pop()},Ot=a=>{const t=m.setSize("sketch");let o=G.setController();const n=tt();let i,e,s;a.setup=async()=>{s=await st(),i=et(s,a.millis()),e=nt(i,t,n,s),a.createCanvas(t,t);const r=G.setGui(a,o,s.se,!1);vt(n,r),a.colorMode(a.HSB),a.noLoop(),Z(a,t)},a.draw=()=>{if(s===void 0){a.noLoop();return}yt({results:"na"},5),a.background(255),G.updateController(a,o),i=Pt(i,n,a.millis()),e=St(e,i,n,t),Et(e,i,n,a),Z(a,t),Mt(s,i,e,n,a.frameCount)}};export{Ot as sketch};
