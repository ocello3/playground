import{T as R,o as _,G as O,p as N,u as $,w as j,v as q,s as Y,h as H,t as P,l as J,c as V,d as T}from"./tools.55a1086d.js";import{d as K}from"./debug.707651d3.js";import{G as Q}from"./GrainPlayer.d4d0b9c1.js";import{p as m}from"./index.27a31525.js";class x extends R{constructor(){super(_(x.getDefaults(),arguments,["channels"])),this.name="Split";const t=_(x.getDefaults(),arguments,["channels"]);this._splitter=this.input=this.output=this.context.createChannelSplitter(t.channels),this._internalChannels=[this._splitter]}static getDefaults(){return Object.assign(R.getDefaults(),{channels:2})}dispose(){return super.dispose(),this._splitter.disconnect(),this}}class S extends R{constructor(){super(_(S.getDefaults(),arguments,["type","size"])),this.name="Analyser",this._analysers=[],this._buffers=[];const t=_(S.getDefaults(),arguments,["type","size"]);this.input=this.output=this._gain=new O({context:this.context}),this._split=new x({context:this.context,channels:t.channels}),this.input.connect(this._split),N(t.channels,1);for(let o=0;o<t.channels;o++)this._analysers[o]=this.context.createAnalyser(),this._split.connect(this._analysers[o],o,0);this.size=t.size,this.type=t.type}static getDefaults(){return Object.assign(R.getDefaults(),{size:1024,smoothing:.8,type:"fft",channels:1})}getValue(){return this._analysers.forEach((t,o)=>{const e=this._buffers[o];this._type==="fft"?t.getFloatFrequencyData(e):this._type==="waveform"&&t.getFloatTimeDomainData(e)}),this.channels===1?this._buffers[0]:this._buffers}get size(){return this._analysers[0].frequencyBinCount}set size(t){this._analysers.forEach((o,e)=>{o.fftSize=t*2,this._buffers[e]=new Float32Array(t)})}get channels(){return this._analysers.length}get type(){return this._type}set type(t){$(t==="waveform"||t==="fft",`Analyser: invalid type: ${t}`),this._type=t}get smoothing(){return this._analysers[0].smoothingTimeConstant}set smoothing(t){this._analysers.forEach(o=>o.smoothingTimeConstant=t)}dispose(){return super.dispose(),this._analysers.forEach(t=>t.disconnect()),this._split.dispose(),this._gain.dispose(),this}}class A extends R{constructor(){super(_(A.getDefaults(),arguments)),this.name="MeterBase",this.input=this.output=this._analyser=new S({context:this.context,size:256,type:"waveform"})}dispose(){return super.dispose(),this._analyser.dispose(),this}}class E extends A{constructor(){super(_(E.getDefaults(),arguments,["smoothing"])),this.name="Meter",this._rms=0;const t=_(E.getDefaults(),arguments,["smoothing"]);this.input=this.output=this._analyser=new S({context:this.context,size:256,type:"waveform",channels:t.channels}),this.smoothing=t.smoothing,this.normalRange=t.normalRange}static getDefaults(){return Object.assign(A.getDefaults(),{smoothing:.8,normalRange:!1,channels:1})}getLevel(){return j("'getLevel' has been changed to 'getValue'"),this.getValue()}getValue(){const t=this._analyser.getValue(),e=(this.channels===1?[t]:t).map(h=>{const n=h.reduce((a,c)=>a+c*c,0),r=Math.sqrt(n/h.length);return this._rms=Math.max(r,this._rms*this.smoothing),this.normalRange?this._rms:q(this._rms)});return this.channels===1?e[0]:e}get channels(){return this._analyser.channels}dispose(){return super.dispose(),this._analyser.dispose(),this}}const D=()=>{const s=["right","right","left","left"];return{marginRate:.2,alignments:s,boxIntervalRate:.01,boxHeightRate:.5/s.length,alphaMin:20,loopRangeLineYPosRate:.65}},U=D(),W=(s,t)=>{t.pages[1].addInput(s,"marginRate",{step:.1,min:.1,max:1})},X="/playground/assets/track_1.043a5dc7.mp3",Z="/playground/assets/track_2.ea523552.mp3",C=async s=>{const t=new J;return await t.load(s),t},v=s=>s.duration,k=(s,t,o)=>{const e=new Q(s).connect(o);return e.volume.value=-5,e.loop=!0,e.loopStart=0,e.grainSize=t,e},I=async()=>{const s=await Y(),t=[await C(X),await C(Z)],o=[v(t[0]),v(t[1]),v(t[0]),v(t[1])],e=o.map(()=>new H().toDestination());e.forEach((n,r)=>{n.set({pan:P.map(r,0,o.length,-1,1)})});const h=o.map((n,r)=>k(t[r%2],n,e[r]));return{se:s,panners:e,players:h,data:{durations:o}}},M=await I(),B=(s,t,o,e)=>{e==2&&s.players.forEach(h=>h.start()),t.loopRetentionFrames.forEach((h,n)=>{h===0&&(s.panners[n].pan.value=o.panValues[n],s.players[n].reverse=t.loopIsReverses[n],s.players[n].loopStart=t.loopStartTimes[n],s.players[n].grainSize=t.loopGrainSizes[n],s.players[n].playbackRate=t.playbackRates[n])})},z=s=>{const t=s.data.durations,o=t.reduce((l,p)=>p>l?p:l,0),e=t.map(()=>0),h=t.map(l=>l),n=t.map(()=>!1),r=t.map(()=>!1),a=t.map(()=>1),c=t.map(()=>1),i=t.map(()=>new E);return s.players.forEach((l,p)=>l.connect(i[p])),{durations:t,longestDuration:o,loopStartTimes:e,loopEndTimes:h,loopIsReverses:n,loopIsSwitches:r,loopGrainSizes:h,loopRetentionFrames:a,playbackRates:c,volumes:i}},tt=z(M),st=s=>{const t={...s};return t.loopRetentionFrames=s.loopRetentionFrames.map((o,e)=>o>0?o-1:s.durations[e]*60),t.loopIsSwitches=t.loopRetentionFrames.map(o=>o===0),t.loopStartTimes=s.loopStartTimes.map((o,e)=>t.loopIsSwitches[e]?Math.random()*s.durations[e]:o),t.loopEndTimes=s.loopEndTimes.map((o,e)=>t.loopIsSwitches[e]?Math.random()*s.durations[e]:o),t.loopIsReverses=s.loopIsReverses.map((o,e)=>t.loopIsSwitches[e]?t.loopStartTimes[e]>t.loopEndTimes[e]:o),t.loopGrainSizes=t.loopEndTimes.map((o,e)=>Math.abs(o-t.loopStartTimes[e])),t.playbackRates=s.playbackRates.map((o,e)=>t.loopIsSwitches[e]?P.map(Math.random(),0,1,.5,2.5):o),t},F=(s,t,o,e)=>{const{marginRate:h}=o,r=t*(1-h)/s.longestDuration,a=e.data.durations.map(y=>y*r),c=o.alignments.map((y,d)=>{const w=t*h*.5;return y==="right"?w:t-a[d]-w}),i=e.data.durations.map((y,d)=>{const w=c[d],G=t/(e.data.durations.length+1)*(d+1);return new m.Vector().set(w,G)}),l=i.map((y,d)=>m.Vector.add(y,new m.Vector().set(a[d],0))),p=new m.Vector().set(t*o.boxIntervalRate,t*o.boxHeightRate),g=i.map((y,d)=>{const w=y.x-l[d].x;return Math.ceil(Math.abs(w/p.x))}),u=g.map((y,d)=>{const w=new m.Vector().set(0,p.y*-.5);return[m.Vector.add(i[d],w)]}),b=g.map(()=>[0]),f=i.map(()=>!1),L=i.map(y=>P.map(y.x,0,t,-1,1));return{bufferConvertRateToLength:r,fullLengths:a,margins:c,startPositions:i,endPositions:l,loopStartPositions:i,loopEndPositions:l,currentPositions:i,boxSize:p,boxNumbers:g,boxLAPositionArrays:u,boxColorArrays:b,isOvers:f,panValues:L}};F(tt,100,U,M);const ot=(s,t,o,e,h)=>{const n={...s};return n.loopStartPositions=s.loopStartPositions.map((r,a)=>{if(!t.loopIsSwitches[a])return r;const c=r.copy(),i=t.loopStartTimes[a]/t.durations[a],p=s.fullLengths[a]*i+s.margins[a];return c.x=p,c}),n.loopEndPositions=s.loopEndPositions.map((r,a)=>{if(!t.loopIsSwitches[a])return r;const c=r.copy(),i=t.loopEndTimes[a]/t.durations[a],p=s.fullLengths[a]*i+s.margins[a];return c.x=p,c}),n.boxNumbers=s.boxNumbers.map((r,a)=>{if(!t.loopIsSwitches[a])return r;const c=n.loopStartPositions[a].x-n.loopEndPositions[a].x;return Math.ceil(Math.abs(c/s.boxSize.x))}),n.currentPositions=s.currentPositions.map((r,a)=>{const c=m.Vector.dist(n.loopStartPositions[a],n.loopEndPositions[a]),i=t.loopIsSwitches[a]?n.loopStartPositions[a]:r,l=t.loopIsReverses[a]?-1:1,p=c/t.durations[a]/h*t.playbackRates[a]*l,g=new m.Vector().set(p,0),u=m.Vector.add(i,g);return(t.loopIsReverses[a]?u.x<s.loopEndPositions[a].x:u.x>s.loopEndPositions[a].x)?n.loopStartPositions[a]:u}),n.isOvers=n.currentPositions.map((r,a)=>r.x===n.loopStartPositions[a].x),n.boxLAPositionArrays=s.boxLAPositionArrays.map((r,a)=>{if(t.loopIsSwitches[a]||n.isOvers[a]){const u=new m.Vector().set(0,s.boxSize.y*-.5);return[m.Vector.add(n.loopStartPositions[a],u)]}const c=t.loopIsReverses[a]?-1:1,i=r[r.length-1],l=Math.abs(n.currentPositions[a].x-i.x),p=Math.round(l/s.boxSize.x);if(p===0)return r;const g=Array.from(Array(p),(u,b)=>{const f=new m.Vector(s.boxSize.x*(b+1)*c,0);return m.Vector.add(i,f)});return r.concat(g)}),n.boxColorArrays=n.boxLAPositionArrays.map((r,a)=>{const c=s.boxColorArrays[a],i=r.length-c.length,l=t.volumes[a].getValue(),p=isFinite(l)?l:0,g=P.map(p,-50,-20,o.alphaMin,255),u=P.constrain(g,o.alphaMin,255);if(i===0)return c[c.length-1]=u,c;if(i>1){const b=Array.from(Array(i),()=>u);return c.concat(b)}else return r.map(()=>u)}),n.panValues=n.currentPositions.map(r=>P.map(r.x,0,e,-1,1)),n},nt=(s,t,o)=>{const{startPositions:e,endPositions:h,loopStartPositions:n,loopEndPositions:r,boxLAPositionArrays:a,boxColorArrays:c,boxSize:i}=s;o.push(),o.stroke(0),o.noFill(),e.forEach((l,p)=>{const u=h[p].x-l.x;o.rect(l.x,l.y-i.y*.5,u,i.y)}),o.pop(),o.push(),o.noFill(),o.stroke(0),n.forEach((l,p)=>{o.line(l.x,l.y+i.y*t.loopRangeLineYPosRate,r[p].x,r[p].y+i.y*t.loopRangeLineYPosRate)}),o.pop(),o.push(),o.noStroke(),a.forEach((l,p)=>{const g=c[p];l.forEach((u,b)=>{const f=g[b];o.fill(0,f),o.rect(u.x,u.y,i.x,i.y)})})},lt=s=>{const t=P.setSize("sketch");let o=V.setController();const e=D();let h,n,r;s.setup=async()=>{r=await I(),h=z(r),n=F(h,t,e,r),s.createCanvas(t,t);const a=V.setGui(s,o,r.se,!1);W(e,a),s.noLoop(),T(s,t)},s.draw=()=>{if(r===void 0){s.noLoop();return}K({boxNumber:n.boxLAPositionArrays[0].length,boxPos:n.boxLAPositionArrays[0],boxColorArray:n.boxColorArrays[0]},10),s.background(255),V.updateController(s,o),h=st(h),n=ot(n,h,e,t,s.frameRate()),nt(n,e,s),T(s,t),B(r,h,n,s.frameCount)}};export{lt as sketch};
