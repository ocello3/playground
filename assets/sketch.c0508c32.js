import{T as _,o as f,G as j,p as q,u as H,w as W,v as J,s as K,h as Q,t as b,l as U,c as I,d as M}from"./tools.de97e3ea.js";import{d as X}from"./debug.ef9170f5.js";import{G as Y}from"./GrainPlayer.da968ae1.js";import{p as u}from"./index.f90f417b.js";class R extends _{constructor(){super(f(R.getDefaults(),arguments,["channels"])),this.name="Split";const t=f(R.getDefaults(),arguments,["channels"]);this._splitter=this.input=this.output=this.context.createChannelSplitter(t.channels),this._internalChannels=[this._splitter]}static getDefaults(){return Object.assign(_.getDefaults(),{channels:2})}dispose(){return super.dispose(),this._splitter.disconnect(),this}}class v extends _{constructor(){super(f(v.getDefaults(),arguments,["type","size"])),this.name="Analyser",this._analysers=[],this._buffers=[];const t=f(v.getDefaults(),arguments,["type","size"]);this.input=this.output=this._gain=new j({context:this.context}),this._split=new R({context:this.context,channels:t.channels}),this.input.connect(this._split),q(t.channels,1);for(let e=0;e<t.channels;e++)this._analysers[e]=this.context.createAnalyser(),this._split.connect(this._analysers[e],e,0);this.size=t.size,this.type=t.type}static getDefaults(){return Object.assign(_.getDefaults(),{size:1024,smoothing:.8,type:"fft",channels:1})}getValue(){return this._analysers.forEach((t,e)=>{const a=this._buffers[e];this._type==="fft"?t.getFloatFrequencyData(a):this._type==="waveform"&&t.getFloatTimeDomainData(a)}),this.channels===1?this._buffers[0]:this._buffers}get size(){return this._analysers[0].frequencyBinCount}set size(t){this._analysers.forEach((e,a)=>{e.fftSize=t*2,this._buffers[a]=new Float32Array(t)})}get channels(){return this._analysers.length}get type(){return this._type}set type(t){H(t==="waveform"||t==="fft",`Analyser: invalid type: ${t}`),this._type=t}get smoothing(){return this._analysers[0].smoothingTimeConstant}set smoothing(t){this._analysers.forEach(e=>e.smoothingTimeConstant=t)}dispose(){return super.dispose(),this._analysers.forEach(t=>t.disconnect()),this._split.dispose(),this._gain.dispose(),this}}class x extends _{constructor(){super(f(x.getDefaults(),arguments)),this.name="MeterBase",this.input=this.output=this._analyser=new v({context:this.context,size:256,type:"waveform"})}dispose(){return super.dispose(),this._analyser.dispose(),this}}class E extends x{constructor(){super(f(E.getDefaults(),arguments,["smoothing"])),this.name="Meter",this._rms=0;const t=f(E.getDefaults(),arguments,["smoothing"]);this.input=this.output=this._analyser=new v({context:this.context,size:256,type:"waveform",channels:t.channels}),this.smoothing=t.smoothing,this.normalRange=t.normalRange}static getDefaults(){return Object.assign(x.getDefaults(),{smoothing:.8,normalRange:!1,channels:1})}getLevel(){return W("'getLevel' has been changed to 'getValue'"),this.getValue()}getValue(){const t=this._analyser.getValue(),a=(this.channels===1?[t]:t).map(p=>{const n=p.reduce((o,l)=>o+l*l,0),r=Math.sqrt(n/p.length);return this._rms=Math.max(r,this._rms*this.smoothing),this.normalRange?this._rms:J(this._rms)});return this.channels===1?a[0]:a}get channels(){return this._analyser.channels}dispose(){return super.dispose(),this._analyser.dispose(),this}}const C=()=>{const s=["right","right","left","left"];return{marginRate:.2,alignments:s,boxIntervalRate:.015,boxHeightRate:.5/s.length,alphaMin:20}},Z=C(),k=(s,t)=>{t.pages[1].addInput(s,"marginRate",{step:.1,min:.1,max:1})},B="/playground/assets/track_1.043a5dc7.mp3",tt="/playground/assets/track_2.ea523552.mp3",T=async s=>{const t=new U;return await t.load(s),t},A=s=>s.duration,st=(s,t,e)=>{const a=new Y(s).connect(e);return a.volume.value=-5,a.loop=!0,a.loopStart=0,a.grainSize=t,a},D=async()=>{const s=await K(),t=[await T(B),await T(tt)],e=[A(t[0]),A(t[1]),A(t[0]),A(t[1])],a=e.map(()=>new Q().toDestination());a.forEach((n,r)=>{n.set({pan:b.map(r,0,e.length,-1,1)})});const p=e.map((n,r)=>st(t[r%2],n,a[r]));return{se:s,panners:a,players:p,data:{durations:e}}},z=await D(),ot=(s,t,e,a)=>{a==2&&s.players.forEach(p=>p.start()),t.loopRetentionFrames.forEach((p,n)=>{p===0&&(s.panners[n].pan.value=e.panValues[n],s.players[n].reverse=t.loopIsReverses[n],s.players[n].loopStart=t.loopStartTimes[n],s.players[n].grainSize=t.loopGrainSizes[n],s.players[n].playbackRate=t.playbackRates[n])})},F=s=>{const t=s.data.durations,e=t.reduce((c,h)=>h>c?h:c,0),a=t.map(()=>0),p=t.map(c=>c),n=t.map(()=>!1),r=t.map(()=>!1),o=t.map(()=>1),l=t.map(()=>1),i=t.map(()=>new E);return s.players.forEach((c,h)=>c.connect(i[h])),{durations:t,longestDuration:e,loopStartTimes:a,loopEndTimes:p,loopIsReverses:n,loopIsSwitches:r,loopGrainSizes:p,loopRetentionFrames:o,playbackRates:l,volumes:i}},nt=F(z),et=s=>{const t={...s};return t.loopRetentionFrames=s.loopRetentionFrames.map((e,a)=>e>0?e-1:s.durations[a]*60),t.loopIsSwitches=t.loopRetentionFrames.map(e=>e===0),t.loopStartTimes=s.loopStartTimes.map((e,a)=>t.loopIsSwitches[a]?Math.random()*s.durations[a]:e),t.loopEndTimes=s.loopEndTimes.map((e,a)=>t.loopIsSwitches[a]?Math.random()*s.durations[a]:e),t.loopIsReverses=s.loopIsReverses.map((e,a)=>t.loopIsSwitches[a]?t.loopStartTimes[a]>t.loopEndTimes[a]:e),t.loopGrainSizes=t.loopEndTimes.map((e,a)=>Math.abs(e-t.loopStartTimes[a])),t.playbackRates=s.playbackRates.map((e,a)=>t.loopIsSwitches[a]?b.map(Math.random(),0,1,.5,2.5):e),t},L=(s,t,e,a)=>{const{marginRate:p}=e,r=t*(1-p)/s.longestDuration,o=a.data.durations.map(m=>m*r),l=e.alignments.map((m,y)=>{const P=t*p*.5;return m==="right"?P:t-o[y]-P}),i=a.data.durations.map((m,y)=>{const P=l[y],$=t/(a.data.durations.length+1)*(y+1);return new u.Vector().set(P,$)}),c=i.map((m,y)=>u.Vector.add(m,new u.Vector().set(o[y],0))),h=new u.Vector().set(t*e.boxIntervalRate,t*e.boxHeightRate),d=i.map((m,y)=>{const P=m.x-c[y].x;return Math.ceil(Math.abs(P/h.x))}),g=d.map((m,y)=>{const P=new u.Vector().set(0,h.y*-.5);return[u.Vector.add(i[y],P)]}),w=d.map(()=>[0]),S=i.map(()=>!1),O=i.map(m=>[m]),G=i.map(m=>b.map(m.x,0,t,-1,1)),V=t*.03,N={forward:{upperPositions:c.map(m=>u.Vector.add(m,u.Vector.fromAngle(3/4*Math.PI,V))),lowerPositions:c.map(m=>u.Vector.add(m,u.Vector.fromAngle(-3/4*Math.PI,V)))},reverse:{upperPositions:i.map(m=>u.Vector.add(m,u.Vector.fromAngle(1/4*Math.PI,V))),lowerPositions:i.map(m=>u.Vector.add(m,u.Vector.fromAngle(-1/4*Math.PI,V)))}};return{bufferConvertRateToLength:r,fullLengths:o,margins:l,startPositions:i,endPositions:c,loopStartPositions:i,loopEndPositions:c,currentPositions:i,boxSize:h,boxNumbers:d,boxLAPositionArrays:g,boxColorArrays:w,isOvers:S,arrowPositions:N,panValues:G,volumePositionArrays:O}};L(nt,100,Z,z);const at=(s,t,e,a,p)=>{const n={...s};return n.loopStartPositions=s.loopStartPositions.map((r,o)=>{if(!t.loopIsSwitches[o])return r;const l=r.copy(),i=t.loopStartTimes[o]/t.durations[o],h=s.fullLengths[o]*i+s.margins[o];return l.x=h,l}),n.loopEndPositions=s.loopEndPositions.map((r,o)=>{if(!t.loopIsSwitches[o])return r;const l=r.copy(),i=t.loopEndTimes[o]/t.durations[o],h=s.fullLengths[o]*i+s.margins[o];return l.x=h,l}),n.boxNumbers=s.boxNumbers.map((r,o)=>{if(!t.loopIsSwitches[o])return r;const l=n.loopStartPositions[o].x-n.loopEndPositions[o].x;return Math.ceil(Math.abs(l/s.boxSize.x))}),n.currentPositions=s.currentPositions.map((r,o)=>{const l=u.Vector.dist(n.loopStartPositions[o],n.loopEndPositions[o]),i=t.loopIsSwitches[o]?n.loopStartPositions[o]:r,c=t.loopIsReverses[o]?-1:1,h=l/t.durations[o]/p*t.playbackRates[o]*c,d=new u.Vector().set(h,0),g=u.Vector.add(i,d);return(t.loopIsReverses[o]?g.x<s.loopEndPositions[o].x:g.x>s.loopEndPositions[o].x)?n.loopStartPositions[o]:g}),n.boxLAPositionArrays=s.boxLAPositionArrays.map((r,o)=>{if(t.loopIsSwitches[o]||n.isOvers[o]){const g=new u.Vector().set(0,s.boxSize.y*-.5);return[u.Vector.add(n.loopStartPositions[o],g)]}const l=t.loopIsReverses[o]?-1:1,i=r[r.length-1],c=Math.abs(n.currentPositions[o].x-i.x),h=Math.round(c/s.boxSize.x);if(h===0)return r;const d=Array.from(Array(h),(g,w)=>{const S=new u.Vector(s.boxSize.x*(w+1)*l,0);return u.Vector.add(i,S)});return r.concat(d)}),n.boxColorArrays=n.boxLAPositionArrays.map((r,o)=>{const l=s.boxColorArrays[o],i=r.length-l.length,c=t.volumes[o].getValue(),h=isFinite(c)?c:0,d=b.map(h,-50,-20,e.alphaMin,255),g=b.constrain(d,e.alphaMin,255);if(i===0)return l[l.length-1]=g,l;if(i>1){const w=Array.from(Array(i),()=>g);return l.concat(w)}else return r.map(()=>g)}),n.isOvers=n.currentPositions.map((r,o)=>r.x===n.loopStartPositions[o].x),n.volumePositionArrays=s.volumePositionArrays.map((r,o)=>{if(n.isOvers[o]||t.loopIsSwitches[o])return[n.loopStartPositions[o]];const l=r.slice(-1)[0];if(Math.abs(l.x-n.currentPositions[o].x)<1)return r;const c=n.currentPositions[o].copy(),h=t.volumes[o].getValue(),d=isFinite(h)?h:0,g=b.map(d,-50,-20,0,20),w=g<0?0:g;return c.add(new u.Vector().set(0,-w)),r.push(c),r}),n.panValues=n.currentPositions.map(r=>b.map(r.x,0,a,-1,1)),n},rt=(s,t)=>{const{startPositions:e,endPositions:a,boxLAPositionArrays:p,boxColorArrays:n,boxSize:r}=s;t.push(),t.stroke(0),e.forEach((o,l)=>{const i=a[l];t.line(o.x,o.y,i.x,i.y)}),t.pop(),t.push(),t.noStroke(),p.forEach((o,l)=>{const i=n[l];o.forEach((c,h)=>{const d=i[h];t.fill(0,d),t.rect(c.x,c.y,r.x,r.y)})})},ht=s=>{const t=b.setSize("sketch");let e=I.setController();const a=C();let p,n,r;s.setup=async()=>{r=await D(),p=F(r),n=L(p,t,a,r),s.createCanvas(t,t);const o=I.setGui(s,e,r.se,!1);k(a,o),s.noLoop(),M(s,t)},s.draw=()=>{if(r===void 0){s.noLoop();return}X({boxNumber:n.boxLAPositionArrays[0].length,boxPos:n.boxLAPositionArrays[0],boxColorArray:n.boxColorArrays[0]},10),s.background(255),I.updateController(s,e),p=et(p),n=at(n,p,a,t,s.frameRate()),rt(n,s),M(s,t),ot(r,p,n,s.frameCount)}};export{ht as sketch};
