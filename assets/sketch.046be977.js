import{T as P,o as y,G as O,p as $,u as j,w as k,v as q,s as W,h as H,t as w,l as N,c as T,d as D}from"./tools.d7fb69e7.js";import{d as x}from"./debug.bea9d25f.js";import{G as J}from"./GrainPlayer.a1d43c80.js";import{p as m}from"./index.6cf80624.js";class E extends P{constructor(){super(y(E.getDefaults(),arguments,["channels"])),this.name="Split";const t=y(E.getDefaults(),arguments,["channels"]);this._splitter=this.input=this.output=this.context.createChannelSplitter(t.channels),this._internalChannels=[this._splitter]}static getDefaults(){return Object.assign(P.getDefaults(),{channels:2})}dispose(){return super.dispose(),this._splitter.disconnect(),this}}class f extends P{constructor(){super(y(f.getDefaults(),arguments,["type","size"])),this.name="Analyser",this._analysers=[],this._buffers=[];const t=y(f.getDefaults(),arguments,["type","size"]);this.input=this.output=this._gain=new O({context:this.context}),this._split=new E({context:this.context,channels:t.channels}),this.input.connect(this._split),$(t.channels,1);for(let s=0;s<t.channels;s++)this._analysers[s]=this.context.createAnalyser(),this._split.connect(this._analysers[s],s,0);this.size=t.size,this.type=t.type}static getDefaults(){return Object.assign(P.getDefaults(),{size:1024,smoothing:.8,type:"fft",channels:1})}getValue(){return this._analysers.forEach((t,s)=>{const n=this._buffers[s];this._type==="fft"?t.getFloatFrequencyData(n):this._type==="waveform"&&t.getFloatTimeDomainData(n)}),this.channels===1?this._buffers[0]:this._buffers}get size(){return this._analysers[0].frequencyBinCount}set size(t){this._analysers.forEach((s,n)=>{s.fftSize=t*2,this._buffers[n]=new Float32Array(t)})}get channels(){return this._analysers.length}get type(){return this._type}set type(t){j(t==="waveform"||t==="fft",`Analyser: invalid type: ${t}`),this._type=t}get smoothing(){return this._analysers[0].smoothingTimeConstant}set smoothing(t){this._analysers.forEach(s=>s.smoothingTimeConstant=t)}dispose(){return super.dispose(),this._analysers.forEach(t=>t.disconnect()),this._split.dispose(),this._gain.dispose(),this}}class I extends P{constructor(){super(y(I.getDefaults(),arguments)),this.name="MeterBase",this.input=this.output=this._analyser=new f({context:this.context,size:256,type:"waveform"})}dispose(){return super.dispose(),this._analyser.dispose(),this}}class V extends I{constructor(){super(y(V.getDefaults(),arguments,["smoothing"])),this.name="Meter",this._rms=0;const t=y(V.getDefaults(),arguments,["smoothing"]);this.input=this.output=this._analyser=new f({context:this.context,size:256,type:"waveform",channels:t.channels}),this.smoothing=t.smoothing,this.normalRange=t.normalRange}static getDefaults(){return Object.assign(I.getDefaults(),{smoothing:.8,normalRange:!1,channels:1})}getLevel(){return k("'getLevel' has been changed to 'getValue'"),this.getValue()}getValue(){const t=this._analyser.getValue(),n=(this.channels===1?[t]:t).map(a=>{const r=a.reduce((c,h)=>c+h*h,0),e=Math.sqrt(r/a.length);return this._rms=Math.max(e,this._rms*this.smoothing),this.normalRange?this._rms:q(this._rms)});return this.channels===1?n[0]:n}get channels(){return this._analyser.channels}dispose(){return super.dispose(),this._analyser.dispose(),this}}const F=()=>({marginRate:.2,alignments:["right","right","left","left"]}),K=F(),Q=(o,t)=>{t.pages[1].addInput(o,"marginRate",{step:.1,min:.1,max:1})},U="/playground/assets/track_1.043a5dc7.mp3",X="/playground/assets/track_2.ea523552.mp3",b=async o=>{const t=new N;return await t.load(o),t},R=o=>o.duration,Y=(o,t,s)=>{const n=new J(o).connect(s);return n.volume.value=-5,n.loop=!0,n.loopStart=0,n.grainSize=t,n},A=async()=>{const o=await W(),t=[await b(U),await b(X)],s=[R(t[0]),R(t[1]),R(t[0]),R(t[1])],n=s.map(()=>new H().toDestination());n.forEach((r,e)=>{r.set({pan:w.map(e,0,s.length,-1,1)})});const a=s.map((r,e)=>Y(t[e%2],r,n[e]));return{se:o,panners:n,players:a,data:{durations:s}}},M=await A(),Z=(o,t,s,n)=>{n==2&&o.players.forEach(a=>a.start()),t.loopRetentionFrames.forEach((a,r)=>{a===0&&(o.panners[r].pan.value=s.panValues[r],o.players[r].reverse=t.loopIsReverses[r],o.players[r].loopStart=t.loopStartTimes[r],o.players[r].grainSize=t.loopGrainSizes[r],o.players[r].playbackRate=t.playbackRates[r])})},z=o=>{const t=o.data.durations,s=t.reduce((l,u)=>u>l?u:l,0),n=t.map(()=>0),a=t.map(l=>l),r=t.map(()=>!1),e=t.map(()=>!1),c=t.map(()=>1),h=t.map(()=>1),i=t.map(()=>new V);return o.players.forEach((l,u)=>l.connect(i[u])),{durations:t,longestDuration:s,loopStartTimes:n,loopEndTimes:a,loopIsReverses:r,loopIsSwitches:e,loopGrainSizes:a,loopRetentionFrames:c,playbackRates:h,volumes:i}},B=z(M),tt=o=>{const t={...o};return t.loopRetentionFrames=o.loopRetentionFrames.map((s,n)=>s>0?s-1:o.durations[n]*60),t.loopIsSwitches=t.loopRetentionFrames.map(s=>s===0),t.loopStartTimes=o.loopStartTimes.map((s,n)=>t.loopIsSwitches[n]?Math.random()*o.durations[n]:s),t.loopEndTimes=o.loopEndTimes.map((s,n)=>t.loopIsSwitches[n]?Math.random()*o.durations[n]:s),t.loopIsReverses=o.loopIsReverses.map((s,n)=>t.loopIsSwitches[n]?t.loopStartTimes[n]>t.loopEndTimes[n]:s),t.loopGrainSizes=t.loopEndTimes.map((s,n)=>Math.abs(s-t.loopStartTimes[n])),t.playbackRates=o.playbackRates.map((s,n)=>t.loopIsSwitches[n]?w.map(Math.random(),0,1,.5,2.5):s),t},C=(o,t,s,n)=>{const{marginRate:a}=s,e=t*(1-a)/o.longestDuration,c=n.data.durations.map(p=>p*e),h=s.alignments.map((p,d)=>{const S=t*a*.5;return p==="right"?S:t-c[d]-S}),i=n.data.durations.map((p,d)=>{const S=h[d],G=t/(n.data.durations.length+1)*(d+1);return new m.Vector().set(S,G)}),l=i.map((p,d)=>m.Vector.add(p,new m.Vector().set(c[d],0))),u=i.map(()=>!1),g=i.map(p=>[p]),v=i.map(p=>w.map(p.x,0,t,-1,1)),_=t*.03,L={forward:{upperPositions:l.map(p=>m.Vector.add(p,m.Vector.fromAngle(3/4*Math.PI,_))),lowerPositions:l.map(p=>m.Vector.add(p,m.Vector.fromAngle(-3/4*Math.PI,_)))},reverse:{upperPositions:i.map(p=>m.Vector.add(p,m.Vector.fromAngle(1/4*Math.PI,_))),lowerPositions:i.map(p=>m.Vector.add(p,m.Vector.fromAngle(-1/4*Math.PI,_)))}};return{bufferConvertRateToLength:e,fullLengths:c,margins:h,startPositions:i,endPositions:l,loopStartPositions:i,loopEndPositions:l,currentPositions:i,isOvers:u,arrowPositions:L,panValues:v,volumePositionArrays:g}};C(B,100,K,M);const st=(o,t,s,n)=>{const a={...o};return a.loopStartPositions=o.loopStartPositions.map((r,e)=>{if(!t.loopIsSwitches[e])return r;const c=r.copy(),h=t.loopStartTimes[e]/t.durations[e],l=o.fullLengths[e]*h+o.margins[e];return c.x=l,c}),a.loopEndPositions=o.loopEndPositions.map((r,e)=>{if(!t.loopIsSwitches[e])return r;const c=r.copy(),h=t.loopEndTimes[e]/t.durations[e],l=o.fullLengths[e]*h+o.margins[e];return c.x=l,c}),a.currentPositions=o.currentPositions.map((r,e)=>{const c=m.Vector.dist(a.loopStartPositions[e],a.loopEndPositions[e]),h=t.loopIsSwitches[e]?a.loopStartPositions[e]:r,i=t.loopIsReverses[e]?-1:1,l=c/t.durations[e]/n*t.playbackRates[e]*i,u=new m.Vector().set(l,0),g=m.Vector.add(h,u);return(t.loopIsReverses[e]?g.x<o.loopEndPositions[e].x:g.x>o.loopEndPositions[e].x)?a.loopStartPositions[e]:g}),a.isOvers=a.currentPositions.map((r,e)=>r.x===a.loopStartPositions[e].x),a.volumePositionArrays=o.volumePositionArrays.map((r,e)=>{if(a.isOvers[e]||t.loopIsSwitches[e])return[a.loopStartPositions[e]];const c=r.slice(-1)[0];if(Math.abs(c.x-a.currentPositions[e].x)<1)return r;const i=a.currentPositions[e].copy(),l=t.volumes[e].getValue(),u=isFinite(l)?l:0,g=w.map(u,-50,-20,0,20),v=g<0?0:g;return i.add(new m.Vector().set(0,-v)),r.push(i),r}),a.panValues=a.currentPositions.map(r=>w.map(r.x,0,s,-1,1)),a},ot=(o,t,s)=>{const{startPositions:n,endPositions:a,loopStartPositions:r,loopEndPositions:e,arrowPositions:c,volumePositionArrays:h}=o;s.push(),n.forEach((i,l)=>{const u=a[l];s.line(i.x,i.y,u.x,u.y)}),s.pop(),s.push(),s.fill("blue"),r.forEach(i=>{s.circle(i.x,i.y,10)}),s.pop(),s.push(),s.fill("red"),e.forEach(i=>{s.circle(i.x,i.y,10)}),s.pop(),s.push(),a.forEach((i,l)=>{t.loopIsReverses[l]||s.line(i.x,i.y,c.forward.upperPositions[l].x,c.forward.upperPositions[l].y)}),a.forEach((i,l)=>{t.loopIsReverses[l]||s.line(i.x,i.y,c.forward.lowerPositions[l].x,c.forward.lowerPositions[l].y)}),s.pop(),s.push(),n.forEach((i,l)=>{t.loopIsReverses[l]&&s.line(i.x,i.y,c.reverse.upperPositions[l].x,c.reverse.upperPositions[l].y)}),n.forEach((i,l)=>{t.loopIsReverses[l]&&s.line(i.x,i.y,c.reverse.lowerPositions[l].x,c.reverse.lowerPositions[l].y)}),s.pop(),s.push(),s.noFill(),s.strokeWeight(1),h.forEach((i,l)=>{const u=n[l];i.forEach(g=>{s.line(g.x,u.y,g.x,g.y)})}),s.pop()},it=o=>{const t=w.setSize("sketch");let s=T.setController();const n=F();let a,r,e;o.setup=async()=>{e=await A(),a=z(e),r=C(a,t,n,e),o.createCanvas(t,t);const c=T.setGui(o,s,e.se,!1);Q(n,c),o.noLoop(),D(o,t)},o.draw=()=>{if(e===void 0){o.noLoop();return}x({rms:a.volumes[0].getValue(),volumePositionArray:r.volumePositionArrays[0],startPosition:r.loopStartPositions[0]},5),o.background(255),T.updateController(o,s),a=tt(a),r=st(r,a,t,o.frameRate()),ot(r,a,o),D(o,t),Z(e,a,r,o.frameCount)}};export{it as sketch};
