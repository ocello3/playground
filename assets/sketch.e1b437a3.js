import{t as p,s as v,D as x,d as k,c as R}from"./tools.a311a4f4.js";import{d as S}from"./debug.cb75dd1d.js";import{p as g}from"./index.6a8d32a7.js";const A=()=>({light:{speed:.005,shadowDistRate:100,lightDistRate:.25},boader:{speed:.001},object:{count:10,speed_min:.1,speed_max:1,lengthRate_min:.1,lengthRate_max:.5},maxVolume:-10}),P=(e,n)=>{const o=n.pages[1].addFolder({title:"light"});o.addInput(e.light,"speed",{step:.001,min:.001,max:.1}),o.addInput(e.light,"shadowDistRate",{step:.1,min:1,max:1e3}),o.addInput(e.light,"lightDistRate",{step:.01,min:.01,max:2}),n.pages[2].addInput(e,"maxVolume",{step:1,min:-60,max:0})},V=(e,n,i,o)=>{const s=o===void 0,t=(()=>{if(s)return Math.PI+e.angle;const c=o.angle+n.light.speed;return c>Math.PI*2?c-Math.PI*2:c})(),a=(()=>{const c=t<=e.angle,h=t>=Math.PI+e.angle;return c||h})(),r=s?!0:a!=o.isShadow,d=(()=>{const c=t/(Math.PI*2)-e.angle/(Math.PI*2),h=c<0?1+c:c;if(a){const w=h-.5;return p.map(Math.abs(w-.25),0,.25,1,0)}return p.map(Math.abs(h-.25),0,.25,1,0)})(),l=s?new g.Vector(i*.5,i*.5):o.start,m=(()=>{const c=h=>{const w=new g.Vector(0,0);return g.Vector.dist(l,w)*h};return r||s?c(a?n.light.shadowDistRate:n.light.lightDistRate):o.length})(),u=g.Vector.fromAngle(-1*t),f=g.Vector.add(l,g.Vector.mult(u,m));return{start:l,length:m,angle:t,angleRate:d,vec:u,end:f,isShadow:a,isSwitch:r}},I=(e,n,i)=>{const o=i===void 0,s=(()=>{if(o)return Math.PI;const u=i.angle+e.boader.speed;return u<0?Math.PI:u})(),t=g.Vector.fromAngle(s),a=n*Math.sqrt(2),r=a*.5*Math.cos(s),d=a*.5*Math.sin(s),l=new g.Vector(n*.5-r,n*.5-d),m=new g.Vector(n*.5+r,n*.5+d);return{vec:t,length:a,start:l,end:m,angle:s}},M=(e,n,i,o)=>{const s=o===void 0,t=(()=>s?Array.from(Array(n.object.count),()=>Math.random()):o.rates.map((c,h)=>o.isOvers[h]?Math.random():c))(),a=t.map(c=>p.map(c,0,1,n.object.speed_min,n.object.speed_max)),r=(()=>s?Array.from(Array(n.object.count),()=>Math.random()*e.length):o.intervals.map((c,h)=>o.isOvers[h]?0:c+a[h]))(),d=r.map(c=>g.Vector.add(e.start,g.Vector.mult(e.vec,c))),l=r.map(()=>g.Vector.fromAngle(e.angle+Math.PI*.5)),m=(()=>s?r.map(()=>Math.random()*i*.5):t.map(h=>p.map(h,0,1,n.object.lengthRate_max,n.object.lengthRate_min)).map(h=>i*h))(),u=d.map((c,h)=>g.Vector.add(c,g.Vector.mult(l[h],m[h]))),f=r.map(c=>c>e.length);return{rates:t,speeds:a,intervals:r,starts:d,vecs:l,lengths:m,ends:u,isOvers:f}},y=(e,n,i)=>{const o=i.starts,s=o.map((l,m)=>p.getIntersection(l,e.end,e.end,i.ends[m])),t=i.ends.map((l,m)=>p.getIntersection(l,s[m],n.start,n.end)),a=o.map((l,m)=>g.Vector.sub(s[m],l)),r=a.map(l=>g.Vector.normalize(l)),d=a.map(l=>g.Vector.mag(l));return{starts:o,ends:s,intersections:t,vecs:r,lengths:d}},D=async()=>{const e=await v();return console.log(x.get()),{se:e}},_=(e,n,i,o,s,t)=>{t.push(),t.stroke("black"),t.line(n.start.x,n.start.y,n.end.x,n.end.y),t.pop(),t.push(),t.stroke("black"),i.starts.forEach((a,r)=>{const d=i.ends[r];t.line(a.x,a.y,d.x,d.y)}),t.pop(),t.push(),t.noStroke(),o.starts.forEach((a,r)=>{const d=o.ends[r],l=o.intersections[r];t.fill(0,50*e.angleRate),t.triangle(a.x,a.y,d.x,d.y,i.ends[r].x,i.ends[r].y);const m=e.isShadow?0:240;t.fill(m,130*e.angleRate),t.triangle(a.x,a.y,d.x,d.y,l.x,l.y)}),t.pop(),k(t,s)},j=e=>{const n=p.setSize("sketch");let i=R.setController();const o=A();let s,t,a,r,d;e.setup=async()=>{d=await D(),t=I(o,n),s=V(t,o,n),a=M(t,o,n),r=y(s,t,a),e.createCanvas(n,n);const l=R.setGui(e,i,d.se,!1);P(o,l),e.noLoop()},e.draw=()=>{if(d===void 0){e.noLoop();return}e.frameCount%5===0&&S({na:"na"},10),R.updateController(e,i),t=I(o,n,t),s=V(t,o,n,s),a=M(t,o,n,a),r=y(s,t,a),s.isShadow&&e.background(240,220*s.angleRate),s.isShadow||e.background(100,255*s.angleRate),_(s,t,a,r,n,e)}};export{j as sketch};
